{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### week 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Create a module with a class **SimpleRegression** that will fit and store attributes for ordinary least squares Simple Linear Regression"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img style=\"float: left;\" src=\"img/reg.png\">"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn import datasets\n",
    "import my_module\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on module my_module:\n",
      "\n",
      "NAME\n",
      "    my_module\n",
      "\n",
      "CLASSES\n",
      "    builtins.object\n",
      "        SimpleRegression\n",
      "    \n",
      "    class SimpleRegression(builtins.object)\n",
      "     |  Fits OLS simple regression\n",
      "     |  \n",
      "     |  Methods defined here:\n",
      "     |  \n",
      "     |  __init__(self)\n",
      "     |      Initialize attributes\n",
      "     |  \n",
      "     |  fit(self, X, Y)\n",
      "     |      Fit the OLS model\n",
      "     |  \n",
      "     |  get_a(self, X, Y)\n",
      "     |      Calculate the intercept\n",
      "     |  \n",
      "     |  get_b(self, X, Y)\n",
      "     |      Calculate the coefficient / slope\n",
      "     |  \n",
      "     |  predict(self, X)\n",
      "     |      Predict Y\n",
      "     |  \n",
      "     |  ----------------------------------------------------------------------\n",
      "     |  Data descriptors defined here:\n",
      "     |  \n",
      "     |  __dict__\n",
      "     |      dictionary for instance variables (if defined)\n",
      "     |  \n",
      "     |  __weakref__\n",
      "     |      list of weak references to the object (if defined)\n",
      "\n",
      "FILE\n",
      "    /Users/aaron/repos/visualizedata/ml/week02/my_module.py\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(my_module)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load diabetes dataset\n",
    "diabetes = datasets.load_diabetes()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on package sklearn.datasets in sklearn:\n",
      "\n",
      "NAME\n",
      "    sklearn.datasets\n",
      "\n",
      "DESCRIPTION\n",
      "    The :mod:`sklearn.datasets` module includes utilities to load datasets,\n",
      "    including methods to load and fetch popular reference datasets. It also\n",
      "    features some artificial data generators.\n",
      "\n",
      "PACKAGE CONTENTS\n",
      "    _base\n",
      "    _california_housing\n",
      "    _covtype\n",
      "    _kddcup99\n",
      "    _lfw\n",
      "    _olivetti_faces\n",
      "    _openml\n",
      "    _rcv1\n",
      "    _samples_generator\n",
      "    _species_distributions\n",
      "    _svmlight_format_fast\n",
      "    _svmlight_format_io\n",
      "    _twenty_newsgroups\n",
      "    base\n",
      "    california_housing\n",
      "    covtype\n",
      "    kddcup99\n",
      "    lfw\n",
      "    olivetti_faces\n",
      "    openml\n",
      "    rcv1\n",
      "    samples_generator\n",
      "    setup\n",
      "    species_distributions\n",
      "    svmlight_format\n",
      "    tests (package)\n",
      "    twenty_newsgroups\n",
      "\n",
      "FUNCTIONS\n",
      "    clear_data_home(data_home=None)\n",
      "        Delete all the content of the data home cache.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : str | None\n",
      "            The path to scikit-learn data dir.\n",
      "    \n",
      "    dump_svmlight_file(X, y, f, zero_based=True, comment=None, query_id=None, multilabel=False)\n",
      "        Dump the dataset in svmlight / libsvm file format.\n",
      "        \n",
      "        This format is a text-based format, with one sample per line. It does\n",
      "        not store zero valued features hence is suitable for sparse dataset.\n",
      "        \n",
      "        The first element of each line can be used to store a target variable\n",
      "        to predict.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n",
      "            Training vectors, where n_samples is the number of samples and\n",
      "            n_features is the number of features.\n",
      "        \n",
      "        y : {array-like, sparse matrix}, shape = [n_samples (, n_labels)]\n",
      "            Target values. Class labels must be an\n",
      "            integer or float, or array-like objects of integer or float for\n",
      "            multilabel classifications.\n",
      "        \n",
      "        f : string or file-like in binary mode\n",
      "            If string, specifies the path that will contain the data.\n",
      "            If file-like, data will be written to f. f should be opened in binary\n",
      "            mode.\n",
      "        \n",
      "        zero_based : boolean, optional\n",
      "            Whether column indices should be written zero-based (True) or one-based\n",
      "            (False).\n",
      "        \n",
      "        comment : string, optional\n",
      "            Comment to insert at the top of the file. This should be either a\n",
      "            Unicode string, which will be encoded as UTF-8, or an ASCII byte\n",
      "            string.\n",
      "            If a comment is given, then it will be preceded by one that identifies\n",
      "            the file as having been dumped by scikit-learn. Note that not all\n",
      "            tools grok comments in SVMlight files.\n",
      "        \n",
      "        query_id : array-like of shape (n_samples,)\n",
      "            Array containing pairwise preference constraints (qid in svmlight\n",
      "            format).\n",
      "        \n",
      "        multilabel : boolean, optional\n",
      "            Samples may have several labels each (see\n",
      "            https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html)\n",
      "        \n",
      "            .. versionadded:: 0.17\n",
      "               parameter *multilabel* to support multilabel datasets.\n",
      "    \n",
      "    fetch_20newsgroups(data_home=None, subset='train', categories=None, shuffle=True, random_state=42, remove=(), download_if_missing=True, return_X_y=False)\n",
      "        Load the filenames and data from the 20 newsgroups dataset (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        =================   ==========\n",
      "        Classes                     20\n",
      "        Samples total            18846\n",
      "        Dimensionality               1\n",
      "        Features                  text\n",
      "        =================   ==========\n",
      "        \n",
      "        Read more in the :ref:`User Guide <20newsgroups_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : optional, default: None\n",
      "            Specify a download and cache folder for the datasets. If None,\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        subset : 'train' or 'test', 'all', optional\n",
      "            Select the dataset to load: 'train' for the training set, 'test'\n",
      "            for the test set, 'all' for both, with shuffled ordering.\n",
      "        \n",
      "        categories : None or collection of string or unicode\n",
      "            If None (default), load all the categories.\n",
      "            If not None, list of category names to load (other categories\n",
      "            ignored).\n",
      "        \n",
      "        shuffle : bool, optional\n",
      "            Whether or not to shuffle the data: might be important for models that\n",
      "            make the assumption that the samples are independent and identically\n",
      "            distributed (i.i.d.), such as stochastic gradient descent.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset shuffling. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        remove : tuple\n",
      "            May contain any subset of ('headers', 'footers', 'quotes'). Each of\n",
      "            these are kinds of text that will be detected and removed from the\n",
      "            newsgroup posts, preventing classifiers from overfitting on\n",
      "            metadata.\n",
      "        \n",
      "            'headers' removes newsgroup headers, 'footers' removes blocks at the\n",
      "            ends of posts that look like signatures, and 'quotes' removes lines\n",
      "            that appear to be quoting another post.\n",
      "        \n",
      "            'headers' follows an exact standard; the other filters are not always\n",
      "            correct.\n",
      "        \n",
      "        download_if_missing : optional, True by default\n",
      "            If False, raise an IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        return_X_y : bool, default=False.\n",
      "            If True, returns `(data.data, data.target)` instead of a Bunch\n",
      "            object.\n",
      "        \n",
      "            .. versionadded:: 0.22\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        bunch : Bunch object with the following attribute:\n",
      "            - data: list, length [n_samples]\n",
      "            - target: array, shape [n_samples]\n",
      "            - filenames: list, length [n_samples]\n",
      "            - DESCR: a description of the dataset.\n",
      "            - target_names: a list of categories of the returned data,\n",
      "              length [n_classes]. This depends on the `categories` parameter.\n",
      "        \n",
      "        (data, target) : tuple if `return_X_y=True`\n",
      "            .. versionadded:: 0.22\n",
      "    \n",
      "    fetch_20newsgroups_vectorized(subset='train', remove=(), data_home=None, download_if_missing=True, return_X_y=False, normalize=True)\n",
      "        Load the 20 newsgroups dataset and vectorize it into token counts (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        This is a convenience function; the transformation is done using the\n",
      "        default settings for\n",
      "        :class:`sklearn.feature_extraction.text.CountVectorizer`. For more\n",
      "        advanced usage (stopword filtering, n-gram extraction, etc.), combine\n",
      "        fetch_20newsgroups with a custom\n",
      "        :class:`sklearn.feature_extraction.text.CountVectorizer`,\n",
      "        :class:`sklearn.feature_extraction.text.HashingVectorizer`,\n",
      "        :class:`sklearn.feature_extraction.text.TfidfTransformer` or\n",
      "        :class:`sklearn.feature_extraction.text.TfidfVectorizer`.\n",
      "        \n",
      "        The resulting counts are normalized using\n",
      "        :func:`sklearn.preprocessing.normalize` unless normalize is set to False.\n",
      "        \n",
      "        =================   ==========\n",
      "        Classes                     20\n",
      "        Samples total            18846\n",
      "        Dimensionality          130107\n",
      "        Features                  real\n",
      "        =================   ==========\n",
      "        \n",
      "        Read more in the :ref:`User Guide <20newsgroups_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        subset : 'train' or 'test', 'all', optional\n",
      "            Select the dataset to load: 'train' for the training set, 'test'\n",
      "            for the test set, 'all' for both, with shuffled ordering.\n",
      "        \n",
      "        remove : tuple\n",
      "            May contain any subset of ('headers', 'footers', 'quotes'). Each of\n",
      "            these are kinds of text that will be detected and removed from the\n",
      "            newsgroup posts, preventing classifiers from overfitting on\n",
      "            metadata.\n",
      "        \n",
      "            'headers' removes newsgroup headers, 'footers' removes blocks at the\n",
      "            ends of posts that look like signatures, and 'quotes' removes lines\n",
      "            that appear to be quoting another post.\n",
      "        \n",
      "        data_home : optional, default: None\n",
      "            Specify an download and cache folder for the datasets. If None,\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        download_if_missing : optional, True by default\n",
      "            If False, raise an IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        return_X_y : bool, default=False\n",
      "            If True, returns ``(data.data, data.target)`` instead of a Bunch\n",
      "            object.\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        normalize : bool, default=True\n",
      "            If True, normalizes each document's feature vector to unit norm using\n",
      "            :func:`sklearn.preprocessing.normalize`.\n",
      "        \n",
      "            .. versionadded:: 0.22\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        bunch : Bunch object with the following attribute:\n",
      "            - bunch.data: sparse matrix, shape [n_samples, n_features]\n",
      "            - bunch.target: array, shape [n_samples]\n",
      "            - bunch.target_names: a list of categories of the returned data,\n",
      "              length [n_classes].\n",
      "            - bunch.DESCR: a description of the dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "    \n",
      "    fetch_california_housing(data_home=None, download_if_missing=True, return_X_y=False)\n",
      "        Load the California housing dataset (regression).\n",
      "        \n",
      "        ==============   ==============\n",
      "        Samples total             20640\n",
      "        Dimensionality                8\n",
      "        Features                   real\n",
      "        Target           real 0.15 - 5.\n",
      "        ==============   ==============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <california_housing_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : optional, default: None\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        download_if_missing : optional, default=True\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data.data, data.target)`` instead of a Bunch\n",
      "            object.\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        dataset : dict-like object with the following attributes:\n",
      "        \n",
      "        dataset.data : ndarray, shape [20640, 8]\n",
      "            Each row corresponding to the 8 feature values in order.\n",
      "        \n",
      "        dataset.target : numpy array of shape (20640,)\n",
      "            Each value corresponds to the average house value in units of 100,000.\n",
      "        \n",
      "        dataset.feature_names : array of length 8\n",
      "            Array of ordered feature names used in the dataset.\n",
      "        \n",
      "        dataset.DESCR : string\n",
      "            Description of the California housing dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        \n",
      "        This dataset consists of 20,640 samples and 9 features.\n",
      "    \n",
      "    fetch_covtype(data_home=None, download_if_missing=True, random_state=None, shuffle=False, return_X_y=False)\n",
      "        Load the covertype dataset (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        =================   ============\n",
      "        Classes                        7\n",
      "        Samples total             581012\n",
      "        Dimensionality                54\n",
      "        Features                     int\n",
      "        =================   ============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <covtype_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : string, optional\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        download_if_missing : boolean, default=True\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset shuffling. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        shuffle : bool, default=False\n",
      "            Whether to shuffle dataset.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data.data, data.target)`` instead of a Bunch\n",
      "            object.\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        dataset : dict-like object with the following attributes:\n",
      "        \n",
      "        dataset.data : numpy array of shape (581012, 54)\n",
      "            Each row corresponds to the 54 features in the dataset.\n",
      "        \n",
      "        dataset.target : numpy array of shape (581012,)\n",
      "            Each value corresponds to one of the 7 forest covertypes with values\n",
      "            ranging between 1 to 7.\n",
      "        \n",
      "        dataset.DESCR : string\n",
      "            Description of the forest covertype dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "    \n",
      "    fetch_kddcup99(subset=None, data_home=None, shuffle=False, random_state=None, percent10=True, download_if_missing=True, return_X_y=False)\n",
      "        Load the kddcup99 dataset (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        =================   ====================================\n",
      "        Classes                                               23\n",
      "        Samples total                                    4898431\n",
      "        Dimensionality                                        41\n",
      "        Features            discrete (int) or continuous (float)\n",
      "        =================   ====================================\n",
      "        \n",
      "        Read more in the :ref:`User Guide <kddcup99_dataset>`.\n",
      "        \n",
      "        .. versionadded:: 0.18\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        subset : None, 'SA', 'SF', 'http', 'smtp'\n",
      "            To return the corresponding classical subsets of kddcup 99.\n",
      "            If None, return the entire kddcup 99 dataset.\n",
      "        \n",
      "        data_home : string, optional\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "            .. versionadded:: 0.19\n",
      "        \n",
      "        shuffle : bool, default=False\n",
      "            Whether to shuffle dataset.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset shuffling and for\n",
      "            selection of abnormal samples if `subset='SA'`. Pass an int for\n",
      "            reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        percent10 : bool, default=True\n",
      "            Whether to load only 10 percent of the data.\n",
      "        \n",
      "        download_if_missing : bool, default=True\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object. See\n",
      "            below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are:\n",
      "             - 'data', the data to learn.\n",
      "             - 'target', the regression target for each sample.\n",
      "             - 'DESCR', a description of the dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "    \n",
      "    fetch_lfw_pairs(subset='train', data_home=None, funneled=True, resize=0.5, color=False, slice_=(slice(70, 195, None), slice(78, 172, None)), download_if_missing=True)\n",
      "        Load the Labeled Faces in the Wild (LFW) pairs dataset (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        =================   =======================\n",
      "        Classes                                5749\n",
      "        Samples total                         13233\n",
      "        Dimensionality                         5828\n",
      "        Features            real, between 0 and 255\n",
      "        =================   =======================\n",
      "        \n",
      "        In the official `README.txt`_ this task is described as the\n",
      "        \"Restricted\" task.  As I am not sure as to implement the\n",
      "        \"Unrestricted\" variant correctly, I left it as unsupported for now.\n",
      "        \n",
      "          .. _`README.txt`: http://vis-www.cs.umass.edu/lfw/README.txt\n",
      "        \n",
      "        The original images are 250 x 250 pixels, but the default slice and resize\n",
      "        arguments reduce them to 62 x 47.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <labeled_faces_in_the_wild_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        subset : optional, default: 'train'\n",
      "            Select the dataset to load: 'train' for the development training\n",
      "            set, 'test' for the development test set, and '10_folds' for the\n",
      "            official evaluation set that is meant to be used with a 10-folds\n",
      "            cross validation.\n",
      "        \n",
      "        data_home : optional, default: None\n",
      "            Specify another download and cache folder for the datasets. By\n",
      "            default all scikit-learn data is stored in '~/scikit_learn_data'\n",
      "            subfolders.\n",
      "        \n",
      "        funneled : boolean, optional, default: True\n",
      "            Download and use the funneled variant of the dataset.\n",
      "        \n",
      "        resize : float, optional, default 0.5\n",
      "            Ratio used to resize the each face picture.\n",
      "        \n",
      "        color : boolean, optional, default False\n",
      "            Keep the 3 RGB channels instead of averaging them to a single\n",
      "            gray level channel. If color is True the shape of the data has\n",
      "            one more dimension than the shape with color = False.\n",
      "        \n",
      "        slice_ : optional\n",
      "            Provide a custom 2D slice (height, width) to extract the\n",
      "            'interesting' part of the jpeg files and avoid use statistical\n",
      "            correlation from the background\n",
      "        \n",
      "        download_if_missing : optional, True by default\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        The data is returned as a Bunch object with the following attributes:\n",
      "        \n",
      "        data : numpy array of shape (2200, 5828). Shape depends on ``subset``.\n",
      "            Each row corresponds to 2 ravel'd face images of original size 62 x 47\n",
      "            pixels. Changing the ``slice_``, ``resize`` or ``subset`` parameters\n",
      "            will change the shape of the output.\n",
      "        \n",
      "        pairs : numpy array of shape (2200, 2, 62, 47). Shape depends on ``subset``\n",
      "            Each row has 2 face images corresponding to same or different person\n",
      "            from the dataset containing 5749 people. Changing the ``slice_``,\n",
      "            ``resize`` or ``subset`` parameters will change the shape of the\n",
      "            output.\n",
      "        \n",
      "        target : numpy array of shape (2200,). Shape depends on ``subset``.\n",
      "            Labels associated to each pair of images. The two label values being\n",
      "            different persons or the same person.\n",
      "        \n",
      "        DESCR : string\n",
      "            Description of the Labeled Faces in the Wild (LFW) dataset.\n",
      "    \n",
      "    fetch_lfw_people(data_home=None, funneled=True, resize=0.5, min_faces_per_person=0, color=False, slice_=(slice(70, 195, None), slice(78, 172, None)), download_if_missing=True, return_X_y=False)\n",
      "        Load the Labeled Faces in the Wild (LFW) people dataset (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        =================   =======================\n",
      "        Classes                                5749\n",
      "        Samples total                         13233\n",
      "        Dimensionality                         5828\n",
      "        Features            real, between 0 and 255\n",
      "        =================   =======================\n",
      "        \n",
      "        Read more in the :ref:`User Guide <labeled_faces_in_the_wild_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : optional, default: None\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        funneled : boolean, optional, default: True\n",
      "            Download and use the funneled variant of the dataset.\n",
      "        \n",
      "        resize : float, optional, default 0.5\n",
      "            Ratio used to resize the each face picture.\n",
      "        \n",
      "        min_faces_per_person : int, optional, default None\n",
      "            The extracted dataset will only retain pictures of people that have at\n",
      "            least `min_faces_per_person` different pictures.\n",
      "        \n",
      "        color : boolean, optional, default False\n",
      "            Keep the 3 RGB channels instead of averaging them to a single\n",
      "            gray level channel. If color is True the shape of the data has\n",
      "            one more dimension than the shape with color = False.\n",
      "        \n",
      "        slice_ : optional\n",
      "            Provide a custom 2D slice (height, width) to extract the\n",
      "            'interesting' part of the jpeg files and avoid use statistical\n",
      "            correlation from the background\n",
      "        \n",
      "        download_if_missing : optional, True by default\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(dataset.data, dataset.target)`` instead of a Bunch\n",
      "            object. See below for more information about the `dataset.data` and\n",
      "            `dataset.target` object.\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        dataset : dict-like object with the following attributes:\n",
      "        \n",
      "        dataset.data : numpy array of shape (13233, 2914)\n",
      "            Each row corresponds to a ravelled face image of original size 62 x 47\n",
      "            pixels. Changing the ``slice_`` or resize parameters will change the\n",
      "            shape of the output.\n",
      "        \n",
      "        dataset.images : numpy array of shape (13233, 62, 47)\n",
      "            Each row is a face image corresponding to one of the 5749 people in\n",
      "            the dataset. Changing the ``slice_`` or resize parameters will change\n",
      "            the shape of the output.\n",
      "        \n",
      "        dataset.target : numpy array of shape (13233,)\n",
      "            Labels associated to each face image. Those labels range from 0-5748\n",
      "            and correspond to the person IDs.\n",
      "        \n",
      "        dataset.DESCR : string\n",
      "            Description of the Labeled Faces in the Wild (LFW) dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "    \n",
      "    fetch_olivetti_faces(data_home=None, shuffle=False, random_state=0, download_if_missing=True, return_X_y=False)\n",
      "        Load the Olivetti faces data-set from AT&T (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        =================   =====================\n",
      "        Classes                                40\n",
      "        Samples total                         400\n",
      "        Dimensionality                       4096\n",
      "        Features            real, between 0 and 1\n",
      "        =================   =====================\n",
      "        \n",
      "        Read more in the :ref:`User Guide <olivetti_faces_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : optional, default: None\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        shuffle : boolean, optional\n",
      "            If True the order of the dataset is shuffled to avoid having\n",
      "            images of the same person grouped.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default=0)\n",
      "            Determines random number generation for dataset shuffling. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        download_if_missing : optional, True by default\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns `(data, target)` instead of a `Bunch` object. See\n",
      "            below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.22\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        bunch : Bunch object with the following attributes:\n",
      "            - data: ndarray, shape (400, 4096). Each row corresponds to a ravelled\n",
      "              face image of original size 64 x 64 pixels.\n",
      "            - images : ndarray, shape (400, 64, 64). Each row is a face image\n",
      "              corresponding to one of the 40 subjects of the dataset.\n",
      "            - target : ndarray, shape (400,). Labels associated to each face image.\n",
      "              Those labels are ranging from 0-39 and correspond to the\n",
      "              Subject IDs.\n",
      "            - DESCR : string. Description of the modified Olivetti Faces Dataset.\n",
      "        \n",
      "        (data, target) : tuple if `return_X_y=True`\n",
      "            .. versionadded:: 0.22\n",
      "    \n",
      "    fetch_openml(name=None, version='active', data_id=None, data_home=None, target_column='default-target', cache=True, return_X_y=False, as_frame=False)\n",
      "        Fetch dataset from openml by name or dataset id.\n",
      "        \n",
      "        Datasets are uniquely identified by either an integer ID or by a\n",
      "        combination of name and version (i.e. there might be multiple\n",
      "        versions of the 'iris' dataset). Please give either name or data_id\n",
      "        (not both). In case a name is given, a version can also be\n",
      "        provided.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <openml>`.\n",
      "        \n",
      "        .. note:: EXPERIMENTAL\n",
      "        \n",
      "            The API is experimental (particularly the return value structure),\n",
      "            and might have small backward-incompatible changes in future releases.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        name : str or None\n",
      "            String identifier of the dataset. Note that OpenML can have multiple\n",
      "            datasets with the same name.\n",
      "        \n",
      "        version : integer or 'active', default='active'\n",
      "            Version of the dataset. Can only be provided if also ``name`` is given.\n",
      "            If 'active' the oldest version that's still active is used. Since\n",
      "            there may be more than one active version of a dataset, and those\n",
      "            versions may fundamentally be different from one another, setting an\n",
      "            exact version is highly recommended.\n",
      "        \n",
      "        data_id : int or None\n",
      "            OpenML ID of the dataset. The most specific way of retrieving a\n",
      "            dataset. If data_id is not given, name (and potential version) are\n",
      "            used to obtain a dataset.\n",
      "        \n",
      "        data_home : string or None, default None\n",
      "            Specify another download and cache folder for the data sets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        target_column : string, list or None, default 'default-target'\n",
      "            Specify the column name in the data to use as target. If\n",
      "            'default-target', the standard target column a stored on the server\n",
      "            is used. If ``None``, all columns are returned as data and the\n",
      "            target is ``None``. If list (of strings), all columns with these names\n",
      "            are returned as multi-target (Note: not all scikit-learn classifiers\n",
      "            can handle all types of multi-output combinations)\n",
      "        \n",
      "        cache : boolean, default=True\n",
      "            Whether to cache downloaded datasets using joblib.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object. See\n",
      "            below for more information about the `data` and `target` objects.\n",
      "        \n",
      "        as_frame : boolean, default=False\n",
      "            If True, the data is a pandas DataFrame including columns with\n",
      "            appropriate dtypes (numeric, string or categorical). The target is\n",
      "            a pandas DataFrame or Series depending on the number of target_columns.\n",
      "            The Bunch will contain a ``frame`` attribute with the target and the\n",
      "            data. If ``return_X_y`` is True, then ``(data, target)`` will be pandas\n",
      "            DataFrames or Series as describe above.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        \n",
      "        data : Bunch\n",
      "            Dictionary-like object, with attributes:\n",
      "        \n",
      "            data : np.array, scipy.sparse.csr_matrix of floats, or pandas DataFrame\n",
      "                The feature matrix. Categorical features are encoded as ordinals.\n",
      "            target : np.array, pandas Series or DataFrame\n",
      "                The regression target or classification labels, if applicable.\n",
      "                Dtype is float if numeric, and object if categorical. If\n",
      "                ``as_frame`` is True, ``target`` is a pandas object.\n",
      "            DESCR : str\n",
      "                The full description of the dataset\n",
      "            feature_names : list\n",
      "                The names of the dataset columns\n",
      "            target_names: list\n",
      "                The names of the target columns\n",
      "        \n",
      "            .. versionadded:: 0.22\n",
      "        \n",
      "            categories : dict or None\n",
      "                Maps each categorical feature name to a list of values, such\n",
      "                that the value encoded as i is ith in the list. If ``as_frame``\n",
      "                is True, this is None.\n",
      "            details : dict\n",
      "                More metadata from OpenML\n",
      "            frame : pandas DataFrame\n",
      "                Only present when `as_frame=True`. DataFrame with ``data`` and\n",
      "                ``target``.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. note:: EXPERIMENTAL\n",
      "        \n",
      "                This interface is **experimental** and subsequent releases may\n",
      "                change attributes without notice (although there should only be\n",
      "                minor changes to ``data`` and ``target``).\n",
      "        \n",
      "            Missing values in the 'data' are represented as NaN's. Missing values\n",
      "            in 'target' are represented as NaN's (numerical target) or None\n",
      "            (categorical target)\n",
      "    \n",
      "    fetch_rcv1(data_home=None, subset='all', download_if_missing=True, random_state=None, shuffle=False, return_X_y=False)\n",
      "        Load the RCV1 multilabel dataset (classification).\n",
      "        \n",
      "        Download it if necessary.\n",
      "        \n",
      "        Version: RCV1-v2, vectors, full sets, topics multilabels.\n",
      "        \n",
      "        =================   =====================\n",
      "        Classes                               103\n",
      "        Samples total                      804414\n",
      "        Dimensionality                      47236\n",
      "        Features            real, between 0 and 1\n",
      "        =================   =====================\n",
      "        \n",
      "        Read more in the :ref:`User Guide <rcv1_dataset>`.\n",
      "        \n",
      "        .. versionadded:: 0.17\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : string, optional\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        subset : string, 'train', 'test', or 'all', default='all'\n",
      "            Select the dataset to load: 'train' for the training set\n",
      "            (23149 samples), 'test' for the test set (781265 samples),\n",
      "            'all' for both, with the training samples first if shuffle is False.\n",
      "            This follows the official LYRL2004 chronological split.\n",
      "        \n",
      "        download_if_missing : boolean, default=True\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset shuffling. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        shuffle : bool, default=False\n",
      "            Whether to shuffle dataset.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(dataset.data, dataset.target)`` instead of a Bunch\n",
      "            object. See below for more information about the `dataset.data` and\n",
      "            `dataset.target` object.\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        dataset : dict-like object with the following attributes:\n",
      "        \n",
      "        dataset.data : scipy csr array, dtype np.float64, shape (804414, 47236)\n",
      "            The array has 0.16% of non zero values.\n",
      "        \n",
      "        dataset.target : scipy csr array, dtype np.uint8, shape (804414, 103)\n",
      "            Each sample has a value of 1 in its categories, and 0 in others.\n",
      "            The array has 3.15% of non zero values.\n",
      "        \n",
      "        dataset.sample_id : numpy array, dtype np.uint32, shape (804414,)\n",
      "            Identification number of each sample, as ordered in dataset.data.\n",
      "        \n",
      "        dataset.target_names : numpy array, dtype object, length (103)\n",
      "            Names of each target (RCV1 topics), as ordered in dataset.target.\n",
      "        \n",
      "        dataset.DESCR : string\n",
      "            Description of the RCV1 dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.20\n",
      "    \n",
      "    fetch_species_distributions(data_home=None, download_if_missing=True)\n",
      "        Loader for species distribution dataset from Phillips et. al. (2006)\n",
      "        \n",
      "        Read more in the :ref:`User Guide <datasets>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : optional, default: None\n",
      "            Specify another download and cache folder for the datasets. By default\n",
      "            all scikit-learn data is stored in '~/scikit_learn_data' subfolders.\n",
      "        \n",
      "        download_if_missing : optional, True by default\n",
      "            If False, raise a IOError if the data is not locally available\n",
      "            instead of trying to download the data from the source site.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        The data is returned as a Bunch object with the following attributes:\n",
      "        \n",
      "        coverages : array, shape = [14, 1592, 1212]\n",
      "            These represent the 14 features measured at each point of the map grid.\n",
      "            The latitude/longitude values for the grid are discussed below.\n",
      "            Missing data is represented by the value -9999.\n",
      "        \n",
      "        train : record array, shape = (1624,)\n",
      "            The training points for the data.  Each point has three fields:\n",
      "        \n",
      "            - train['species'] is the species name\n",
      "            - train['dd long'] is the longitude, in degrees\n",
      "            - train['dd lat'] is the latitude, in degrees\n",
      "        \n",
      "        test : record array, shape = (620,)\n",
      "            The test points for the data.  Same format as the training data.\n",
      "        \n",
      "        Nx, Ny : integers\n",
      "            The number of longitudes (x) and latitudes (y) in the grid\n",
      "        \n",
      "        x_left_lower_corner, y_left_lower_corner : floats\n",
      "            The (x,y) position of the lower-left corner, in degrees\n",
      "        \n",
      "        grid_size : float\n",
      "            The spacing between points of the grid, in degrees\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        \n",
      "        * `\"Maximum entropy modeling of species geographic distributions\"\n",
      "          <http://rob.schapire.net/papers/ecolmod.pdf>`_\n",
      "          S. J. Phillips, R. P. Anderson, R. E. Schapire - Ecological Modelling,\n",
      "          190:231-259, 2006.\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        \n",
      "        This dataset represents the geographic distribution of species.\n",
      "        The dataset is provided by Phillips et. al. (2006).\n",
      "        \n",
      "        The two species are:\n",
      "        \n",
      "        - `\"Bradypus variegatus\"\n",
      "          <http://www.iucnredlist.org/details/3038/0>`_ ,\n",
      "          the Brown-throated Sloth.\n",
      "        \n",
      "        - `\"Microryzomys minutus\"\n",
      "          <http://www.iucnredlist.org/details/13408/0>`_ ,\n",
      "          also known as the Forest Small Rice Rat, a rodent that lives in Peru,\n",
      "          Colombia, Ecuador, Peru, and Venezuela.\n",
      "        \n",
      "        - For an example of using this dataset with scikit-learn, see\n",
      "          :ref:`examples/applications/plot_species_distribution_modeling.py\n",
      "          <sphx_glr_auto_examples_applications_plot_species_distribution_modeling.py>`.\n",
      "    \n",
      "    get_data_home(data_home=None)\n",
      "        Return the path of the scikit-learn data dir.\n",
      "        \n",
      "        This folder is used by some large dataset loaders to avoid downloading the\n",
      "        data several times.\n",
      "        \n",
      "        By default the data dir is set to a folder named 'scikit_learn_data' in the\n",
      "        user home folder.\n",
      "        \n",
      "        Alternatively, it can be set by the 'SCIKIT_LEARN_DATA' environment\n",
      "        variable or programmatically by giving an explicit folder path. The '~'\n",
      "        symbol is expanded to the user home folder.\n",
      "        \n",
      "        If the folder does not already exist, it is automatically created.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        data_home : str | None\n",
      "            The path to scikit-learn data dir.\n",
      "    \n",
      "    load_boston(return_X_y=False)\n",
      "        Load and return the boston house-prices dataset (regression).\n",
      "        \n",
      "        ==============   ==============\n",
      "        Samples total               506\n",
      "        Dimensionality               13\n",
      "        Features         real, positive\n",
      "        Targets           real 5. - 50.\n",
      "        ==============   ==============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <boston_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object.\n",
      "            See below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are:\n",
      "            'data', the data to learn, 'target', the regression targets,\n",
      "            'DESCR', the full description of the dataset,\n",
      "            and 'filename', the physical location of boston\n",
      "            csv dataset (added in version `0.20`).\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "            .. versionchanged:: 0.20\n",
      "                Fixed a wrong data point at [445, 0].\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        >>> from sklearn.datasets import load_boston\n",
      "        >>> X, y = load_boston(return_X_y=True)\n",
      "        >>> print(X.shape)\n",
      "        (506, 13)\n",
      "    \n",
      "    load_breast_cancer(return_X_y=False)\n",
      "        Load and return the breast cancer wisconsin dataset (classification).\n",
      "        \n",
      "        The breast cancer dataset is a classic and very easy binary classification\n",
      "        dataset.\n",
      "        \n",
      "        =================   ==============\n",
      "        Classes                          2\n",
      "        Samples per class    212(M),357(B)\n",
      "        Samples total                  569\n",
      "        Dimensionality                  30\n",
      "        Features            real, positive\n",
      "        =================   ==============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <breast_cancer_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        return_X_y : boolean, default=False\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object.\n",
      "            See below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are:\n",
      "            'data', the data to learn, 'target', the classification labels,\n",
      "            'target_names', the meaning of the labels, 'feature_names', the\n",
      "            meaning of the features, and 'DESCR', the full description of\n",
      "            the dataset, 'filename', the physical location of\n",
      "            breast cancer csv dataset (added in version `0.20`).\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        The copy of UCI ML Breast Cancer Wisconsin (Diagnostic) dataset is\n",
      "        downloaded from:\n",
      "        https://goo.gl/U2Uwz2\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        Let's say you are interested in the samples 10, 50, and 85, and want to\n",
      "        know their class name.\n",
      "        \n",
      "        >>> from sklearn.datasets import load_breast_cancer\n",
      "        >>> data = load_breast_cancer()\n",
      "        >>> data.target[[10, 50, 85]]\n",
      "        array([0, 1, 0])\n",
      "        >>> list(data.target_names)\n",
      "        ['malignant', 'benign']\n",
      "    \n",
      "    load_diabetes(return_X_y=False)\n",
      "        Load and return the diabetes dataset (regression).\n",
      "        \n",
      "        ==============   ==================\n",
      "        Samples total    442\n",
      "        Dimensionality   10\n",
      "        Features         real, -.2 < x < .2\n",
      "        Targets          integer 25 - 346\n",
      "        ==============   ==================\n",
      "        \n",
      "        Read more in the :ref:`User Guide <diabetes_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object.\n",
      "            See below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are:\n",
      "            'data', the data to learn, 'target', the regression target for each\n",
      "            sample, 'data_filename', the physical location\n",
      "            of diabetes data csv dataset, and 'target_filename', the physical\n",
      "            location of diabetes targets csv datataset (added in version `0.20`).\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "    \n",
      "    load_digits(n_class=10, return_X_y=False)\n",
      "        Load and return the digits dataset (classification).\n",
      "        \n",
      "        Each datapoint is a 8x8 image of a digit.\n",
      "        \n",
      "        =================   ==============\n",
      "        Classes                         10\n",
      "        Samples per class             ~180\n",
      "        Samples total                 1797\n",
      "        Dimensionality                  64\n",
      "        Features             integers 0-16\n",
      "        =================   ==============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <digits_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_class : integer, between 0 and 10, optional (default=10)\n",
      "            The number of classes to return.\n",
      "        \n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object.\n",
      "            See below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are:\n",
      "            'data', the data to learn, 'images', the images corresponding\n",
      "            to each sample, 'target', the classification labels for each\n",
      "            sample, 'target_names', the meaning of the labels, and 'DESCR',\n",
      "            the full description of the dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        This is a copy of the test set of the UCI ML hand-written digits datasets\n",
      "        https://archive.ics.uci.edu/ml/datasets/Optical+Recognition+of+Handwritten+Digits\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        To load the data and visualize the images::\n",
      "        \n",
      "            >>> from sklearn.datasets import load_digits\n",
      "            >>> digits = load_digits()\n",
      "            >>> print(digits.data.shape)\n",
      "            (1797, 64)\n",
      "            >>> import matplotlib.pyplot as plt #doctest: +SKIP\n",
      "            >>> plt.gray() #doctest: +SKIP\n",
      "            >>> plt.matshow(digits.images[0]) #doctest: +SKIP\n",
      "            >>> plt.show() #doctest: +SKIP\n",
      "    \n",
      "    load_files(container_path, description=None, categories=None, load_content=True, shuffle=True, encoding=None, decode_error='strict', random_state=0)\n",
      "        Load text files with categories as subfolder names.\n",
      "        \n",
      "        Individual samples are assumed to be files stored a two levels folder\n",
      "        structure such as the following:\n",
      "        \n",
      "            container_folder/\n",
      "                category_1_folder/\n",
      "                    file_1.txt\n",
      "                    file_2.txt\n",
      "                    ...\n",
      "                    file_42.txt\n",
      "                category_2_folder/\n",
      "                    file_43.txt\n",
      "                    file_44.txt\n",
      "                    ...\n",
      "        \n",
      "        The folder names are used as supervised signal label names. The individual\n",
      "        file names are not important.\n",
      "        \n",
      "        This function does not try to extract features into a numpy array or scipy\n",
      "        sparse matrix. In addition, if load_content is false it does not try to\n",
      "        load the files in memory.\n",
      "        \n",
      "        To use text files in a scikit-learn classification or clustering algorithm,\n",
      "        you will need to use the :mod`~sklearn.feature_extraction.text` module to\n",
      "        build a feature extraction transformer that suits your problem.\n",
      "        \n",
      "        If you set load_content=True, you should also specify the encoding of the\n",
      "        text using the 'encoding' parameter. For many modern text files, 'utf-8'\n",
      "        will be the correct encoding. If you leave encoding equal to None, then the\n",
      "        content will be made of bytes instead of Unicode, and you will not be able\n",
      "        to use most functions in :mod:`~sklearn.feature_extraction.text`.\n",
      "        \n",
      "        Similar feature extractors should be built for other kind of unstructured\n",
      "        data input such as images, audio, video, ...\n",
      "        \n",
      "        Read more in the :ref:`User Guide <datasets>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        container_path : string or unicode\n",
      "            Path to the main folder holding one subfolder per category\n",
      "        \n",
      "        description : string or unicode, optional (default=None)\n",
      "            A paragraph describing the characteristic of the dataset: its source,\n",
      "            reference, etc.\n",
      "        \n",
      "        categories : A collection of strings or None, optional (default=None)\n",
      "            If None (default), load all the categories. If not None, list of\n",
      "            category names to load (other categories ignored).\n",
      "        \n",
      "        load_content : boolean, optional (default=True)\n",
      "            Whether to load or not the content of the different files. If true a\n",
      "            'data' attribute containing the text information is present in the data\n",
      "            structure returned. If not, a filenames attribute gives the path to the\n",
      "            files.\n",
      "        \n",
      "        shuffle : bool, optional (default=True)\n",
      "            Whether or not to shuffle the data: might be important for models that\n",
      "            make the assumption that the samples are independent and identically\n",
      "            distributed (i.i.d.), such as stochastic gradient descent.\n",
      "        \n",
      "        encoding : string or None (default is None)\n",
      "            If None, do not try to decode the content of the files (e.g. for images\n",
      "            or other non-text content). If not None, encoding to use to decode text\n",
      "            files to Unicode if load_content is True.\n",
      "        \n",
      "        decode_error : {'strict', 'ignore', 'replace'}, optional\n",
      "            Instruction on what to do if a byte sequence is given to analyze that\n",
      "            contains characters not of the given `encoding`. Passed as keyword\n",
      "            argument 'errors' to bytes.decode.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default=0)\n",
      "            Determines random number generation for dataset shuffling. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are: either\n",
      "            data, the raw text data to learn, or 'filenames', the files\n",
      "            holding it, 'target', the classification labels (integer index),\n",
      "            'target_names', the meaning of the labels, and 'DESCR', the full\n",
      "            description of the dataset.\n",
      "    \n",
      "    load_iris(return_X_y=False)\n",
      "        Load and return the iris dataset (classification).\n",
      "        \n",
      "        The iris dataset is a classic and very easy multi-class classification\n",
      "        dataset.\n",
      "        \n",
      "        =================   ==============\n",
      "        Classes                          3\n",
      "        Samples per class               50\n",
      "        Samples total                  150\n",
      "        Dimensionality                   4\n",
      "        Features            real, positive\n",
      "        =================   ==============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <iris_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object. See\n",
      "            below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are:\n",
      "            'data', the data to learn, 'target', the classification labels,\n",
      "            'target_names', the meaning of the labels, 'feature_names', the\n",
      "            meaning of the features, 'DESCR', the full description of\n",
      "            the dataset, 'filename', the physical location of\n",
      "            iris csv dataset (added in version `0.20`).\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "            .. versionchanged:: 0.20\n",
      "                Fixed two wrong data points according to Fisher's paper.\n",
      "                The new version is the same as in R, but not as in the UCI\n",
      "                Machine Learning Repository.\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        Let's say you are interested in the samples 10, 25, and 50, and want to\n",
      "        know their class name.\n",
      "        \n",
      "        >>> from sklearn.datasets import load_iris\n",
      "        >>> data = load_iris()\n",
      "        >>> data.target[[10, 25, 50]]\n",
      "        array([0, 0, 1])\n",
      "        >>> list(data.target_names)\n",
      "        ['setosa', 'versicolor', 'virginica']\n",
      "    \n",
      "    load_linnerud(return_X_y=False)\n",
      "        Load and return the linnerud dataset (multivariate regression).\n",
      "        \n",
      "        ==============   ============================\n",
      "        Samples total    20\n",
      "        Dimensionality   3 (for both data and target)\n",
      "        Features         integer\n",
      "        Targets          integer\n",
      "        ==============   ============================\n",
      "        \n",
      "        Read more in the :ref:`User Guide <linnerrud_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object.\n",
      "            See below for more information about the `data` and `target` object.\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are: 'data' and\n",
      "            'target', the two multivariate datasets, with 'data' corresponding to\n",
      "            the exercise and 'target' corresponding to the physiological\n",
      "            measurements, as well as 'feature_names' and 'target_names'.\n",
      "            In addition, you will also have access to 'data_filename',\n",
      "            the physical location of linnerud data csv dataset, and\n",
      "            'target_filename', the physical location of\n",
      "            linnerud targets csv datataset (added in version `0.20`).\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "            .. versionadded:: 0.18\n",
      "    \n",
      "    load_sample_image(image_name)\n",
      "        Load the numpy array of a single sample image\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_images>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        image_name : {`china.jpg`, `flower.jpg`}\n",
      "            The name of the sample image loaded\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        img : 3D array\n",
      "            The image as a numpy array: height x width x color\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        \n",
      "        >>> from sklearn.datasets import load_sample_image\n",
      "        >>> china = load_sample_image('china.jpg')   # doctest: +SKIP\n",
      "        >>> china.dtype                              # doctest: +SKIP\n",
      "        dtype('uint8')\n",
      "        >>> china.shape                              # doctest: +SKIP\n",
      "        (427, 640, 3)\n",
      "        >>> flower = load_sample_image('flower.jpg') # doctest: +SKIP\n",
      "        >>> flower.dtype                             # doctest: +SKIP\n",
      "        dtype('uint8')\n",
      "        >>> flower.shape                             # doctest: +SKIP\n",
      "        (427, 640, 3)\n",
      "    \n",
      "    load_sample_images()\n",
      "        Load sample images for image manipulation.\n",
      "        \n",
      "        Loads both, ``china`` and ``flower``.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_images>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object with the following attributes : 'images', the\n",
      "            two sample images, 'filenames', the file names for the images, and\n",
      "            'DESCR' the full description of the dataset.\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        To load the data and visualize the images:\n",
      "        \n",
      "        >>> from sklearn.datasets import load_sample_images\n",
      "        >>> dataset = load_sample_images()     #doctest: +SKIP\n",
      "        >>> len(dataset.images)                #doctest: +SKIP\n",
      "        2\n",
      "        >>> first_img_data = dataset.images[0] #doctest: +SKIP\n",
      "        >>> first_img_data.shape               #doctest: +SKIP\n",
      "        (427, 640, 3)\n",
      "        >>> first_img_data.dtype               #doctest: +SKIP\n",
      "        dtype('uint8')\n",
      "    \n",
      "    load_svmlight_file(f, n_features=None, dtype=<class 'numpy.float64'>, multilabel=False, zero_based='auto', query_id=False, offset=0, length=-1)\n",
      "        Load datasets in the svmlight / libsvm format into sparse CSR matrix\n",
      "        \n",
      "        This format is a text-based format, with one sample per line. It does\n",
      "        not store zero valued features hence is suitable for sparse dataset.\n",
      "        \n",
      "        The first element of each line can be used to store a target variable\n",
      "        to predict.\n",
      "        \n",
      "        This format is used as the default format for both svmlight and the\n",
      "        libsvm command line programs.\n",
      "        \n",
      "        Parsing a text based source can be expensive. When working on\n",
      "        repeatedly on the same dataset, it is recommended to wrap this\n",
      "        loader with joblib.Memory.cache to store a memmapped backup of the\n",
      "        CSR results of the first call and benefit from the near instantaneous\n",
      "        loading of memmapped structures for the subsequent calls.\n",
      "        \n",
      "        In case the file contains a pairwise preference constraint (known\n",
      "        as \"qid\" in the svmlight format) these are ignored unless the\n",
      "        query_id parameter is set to True. These pairwise preference\n",
      "        constraints can be used to constraint the combination of samples\n",
      "        when using pairwise loss functions (as is the case in some\n",
      "        learning to rank problems) so that only pairs with the same\n",
      "        query_id value are considered.\n",
      "        \n",
      "        This implementation is written in Cython and is reasonably fast.\n",
      "        However, a faster API-compatible loader is also available at:\n",
      "        \n",
      "          https://github.com/mblondel/svmlight-loader\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        f : {str, file-like, int}\n",
      "            (Path to) a file to load. If a path ends in \".gz\" or \".bz2\", it will\n",
      "            be uncompressed on the fly. If an integer is passed, it is assumed to\n",
      "            be a file descriptor. A file-like or file descriptor will not be closed\n",
      "            by this function. A file-like object must be opened in binary mode.\n",
      "        \n",
      "        n_features : int or None\n",
      "            The number of features to use. If None, it will be inferred. This\n",
      "            argument is useful to load several files that are subsets of a\n",
      "            bigger sliced dataset: each subset might not have examples of\n",
      "            every feature, hence the inferred shape might vary from one\n",
      "            slice to another.\n",
      "            n_features is only required if ``offset`` or ``length`` are passed a\n",
      "            non-default value.\n",
      "        \n",
      "        dtype : numpy data type, default np.float64\n",
      "            Data type of dataset to be loaded. This will be the data type of the\n",
      "            output numpy arrays ``X`` and ``y``.\n",
      "        \n",
      "        multilabel : boolean, optional, default False\n",
      "            Samples may have several labels each (see\n",
      "            https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html)\n",
      "        \n",
      "        zero_based : boolean or \"auto\", optional, default \"auto\"\n",
      "            Whether column indices in f are zero-based (True) or one-based\n",
      "            (False). If column indices are one-based, they are transformed to\n",
      "            zero-based to match Python/NumPy conventions.\n",
      "            If set to \"auto\", a heuristic check is applied to determine this from\n",
      "            the file contents. Both kinds of files occur \"in the wild\", but they\n",
      "            are unfortunately not self-identifying. Using \"auto\" or True should\n",
      "            always be safe when no ``offset`` or ``length`` is passed.\n",
      "            If ``offset`` or ``length`` are passed, the \"auto\" mode falls back\n",
      "            to ``zero_based=True`` to avoid having the heuristic check yield\n",
      "            inconsistent results on different segments of the file.\n",
      "        \n",
      "        query_id : boolean, default False\n",
      "            If True, will return the query_id array for each file.\n",
      "        \n",
      "        offset : integer, optional, default 0\n",
      "            Ignore the offset first bytes by seeking forward, then\n",
      "            discarding the following bytes up until the next new line\n",
      "            character.\n",
      "        \n",
      "        length : integer, optional, default -1\n",
      "            If strictly positive, stop reading any new line of data once the\n",
      "            position in the file has reached the (offset + length) bytes threshold.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : scipy.sparse matrix of shape (n_samples, n_features)\n",
      "        \n",
      "        y : ndarray of shape (n_samples,), or, in the multilabel a list of\n",
      "            tuples of length n_samples.\n",
      "        \n",
      "        query_id : array of shape (n_samples,)\n",
      "           query_id for each sample. Only returned when query_id is set to\n",
      "           True.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        load_svmlight_files: similar function for loading multiple files in this\n",
      "                             format, enforcing the same number of features/columns\n",
      "                             on all of them.\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        To use joblib.Memory to cache the svmlight file::\n",
      "        \n",
      "            from joblib import Memory\n",
      "            from .datasets import load_svmlight_file\n",
      "            mem = Memory(\"./mycache\")\n",
      "        \n",
      "            @mem.cache\n",
      "            def get_data():\n",
      "                data = load_svmlight_file(\"mysvmlightfile\")\n",
      "                return data[0], data[1]\n",
      "        \n",
      "            X, y = get_data()\n",
      "    \n",
      "    load_svmlight_files(files, n_features=None, dtype=<class 'numpy.float64'>, multilabel=False, zero_based='auto', query_id=False, offset=0, length=-1)\n",
      "        Load dataset from multiple files in SVMlight format\n",
      "        \n",
      "        This function is equivalent to mapping load_svmlight_file over a list of\n",
      "        files, except that the results are concatenated into a single, flat list\n",
      "        and the samples vectors are constrained to all have the same number of\n",
      "        features.\n",
      "        \n",
      "        In case the file contains a pairwise preference constraint (known\n",
      "        as \"qid\" in the svmlight format) these are ignored unless the\n",
      "        query_id parameter is set to True. These pairwise preference\n",
      "        constraints can be used to constraint the combination of samples\n",
      "        when using pairwise loss functions (as is the case in some\n",
      "        learning to rank problems) so that only pairs with the same\n",
      "        query_id value are considered.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        files : iterable over {str, file-like, int}\n",
      "            (Paths of) files to load. If a path ends in \".gz\" or \".bz2\", it will\n",
      "            be uncompressed on the fly. If an integer is passed, it is assumed to\n",
      "            be a file descriptor. File-likes and file descriptors will not be\n",
      "            closed by this function. File-like objects must be opened in binary\n",
      "            mode.\n",
      "        \n",
      "        n_features : int or None\n",
      "            The number of features to use. If None, it will be inferred from the\n",
      "            maximum column index occurring in any of the files.\n",
      "        \n",
      "            This can be set to a higher value than the actual number of features\n",
      "            in any of the input files, but setting it to a lower value will cause\n",
      "            an exception to be raised.\n",
      "        \n",
      "        dtype : numpy data type, default np.float64\n",
      "            Data type of dataset to be loaded. This will be the data type of the\n",
      "            output numpy arrays ``X`` and ``y``.\n",
      "        \n",
      "        multilabel : boolean, optional\n",
      "            Samples may have several labels each (see\n",
      "            https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html)\n",
      "        \n",
      "        zero_based : boolean or \"auto\", optional\n",
      "            Whether column indices in f are zero-based (True) or one-based\n",
      "            (False). If column indices are one-based, they are transformed to\n",
      "            zero-based to match Python/NumPy conventions.\n",
      "            If set to \"auto\", a heuristic check is applied to determine this from\n",
      "            the file contents. Both kinds of files occur \"in the wild\", but they\n",
      "            are unfortunately not self-identifying. Using \"auto\" or True should\n",
      "            always be safe when no offset or length is passed.\n",
      "            If offset or length are passed, the \"auto\" mode falls back\n",
      "            to zero_based=True to avoid having the heuristic check yield\n",
      "            inconsistent results on different segments of the file.\n",
      "        \n",
      "        query_id : boolean, defaults to False\n",
      "            If True, will return the query_id array for each file.\n",
      "        \n",
      "        offset : integer, optional, default 0\n",
      "            Ignore the offset first bytes by seeking forward, then\n",
      "            discarding the following bytes up until the next new line\n",
      "            character.\n",
      "        \n",
      "        length : integer, optional, default -1\n",
      "            If strictly positive, stop reading any new line of data once the\n",
      "            position in the file has reached the (offset + length) bytes threshold.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        [X1, y1, ..., Xn, yn]\n",
      "        where each (Xi, yi) pair is the result from load_svmlight_file(files[i]).\n",
      "        \n",
      "        If query_id is set to True, this will return instead [X1, y1, q1,\n",
      "        ..., Xn, yn, qn] where (Xi, yi, qi) is the result from\n",
      "        load_svmlight_file(files[i])\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        When fitting a model to a matrix X_train and evaluating it against a\n",
      "        matrix X_test, it is essential that X_train and X_test have the same\n",
      "        number of features (X_train.shape[1] == X_test.shape[1]). This may not\n",
      "        be the case if you load the files individually with load_svmlight_file.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        load_svmlight_file\n",
      "    \n",
      "    load_wine(return_X_y=False)\n",
      "        Load and return the wine dataset (classification).\n",
      "        \n",
      "        .. versionadded:: 0.18\n",
      "        \n",
      "        The wine dataset is a classic and very easy multi-class classification\n",
      "        dataset.\n",
      "        \n",
      "        =================   ==============\n",
      "        Classes                          3\n",
      "        Samples per class        [59,71,48]\n",
      "        Samples total                  178\n",
      "        Dimensionality                  13\n",
      "        Features            real, positive\n",
      "        =================   ==============\n",
      "        \n",
      "        Read more in the :ref:`User Guide <wine_dataset>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        return_X_y : boolean, default=False.\n",
      "            If True, returns ``(data, target)`` instead of a Bunch object.\n",
      "            See below for more information about the `data` and `target` object.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : Bunch\n",
      "            Dictionary-like object, the interesting attributes are: 'data', the\n",
      "            data to learn, 'target', the classification labels, 'target_names', the\n",
      "            meaning of the labels, 'feature_names', the meaning of the features,\n",
      "            and 'DESCR', the full description of the dataset.\n",
      "        \n",
      "        (data, target) : tuple if ``return_X_y`` is True\n",
      "        \n",
      "        The copy of UCI ML Wine Data Set dataset is downloaded and modified to fit\n",
      "        standard format from:\n",
      "        https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        Let's say you are interested in the samples 10, 80, and 140, and want to\n",
      "        know their class name.\n",
      "        \n",
      "        >>> from sklearn.datasets import load_wine\n",
      "        >>> data = load_wine()\n",
      "        >>> data.target[[10, 80, 140]]\n",
      "        array([0, 1, 2])\n",
      "        >>> list(data.target_names)\n",
      "        ['class_0', 'class_1', 'class_2']\n",
      "    \n",
      "    make_biclusters(shape, n_clusters, noise=0.0, minval=10, maxval=100, shuffle=True, random_state=None)\n",
      "        Generate an array with constant block diagonal structure for\n",
      "        biclustering.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        shape : iterable (n_rows, n_cols)\n",
      "            The shape of the result.\n",
      "        \n",
      "        n_clusters : integer\n",
      "            The number of biclusters.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise.\n",
      "        \n",
      "        minval : int, optional (default=10)\n",
      "            Minimum value of a bicluster.\n",
      "        \n",
      "        maxval : int, optional (default=100)\n",
      "            Maximum value of a bicluster.\n",
      "        \n",
      "        shuffle : boolean, optional (default=True)\n",
      "            Shuffle the samples.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape `shape`\n",
      "            The generated array.\n",
      "        \n",
      "        rows : array of shape (n_clusters, X.shape[0],)\n",
      "            The indicators for cluster membership of each row.\n",
      "        \n",
      "        cols : array of shape (n_clusters, X.shape[1],)\n",
      "            The indicators for cluster membership of each column.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        \n",
      "        .. [1] Dhillon, I. S. (2001, August). Co-clustering documents and\n",
      "            words using bipartite spectral graph partitioning. In Proceedings\n",
      "            of the seventh ACM SIGKDD international conference on Knowledge\n",
      "            discovery and data mining (pp. 269-274). ACM.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_checkerboard\n",
      "    \n",
      "    make_blobs(n_samples=100, n_features=2, centers=None, cluster_std=1.0, center_box=(-10.0, 10.0), shuffle=True, random_state=None)\n",
      "        Generate isotropic Gaussian blobs for clustering.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int or array-like, optional (default=100)\n",
      "            If int, it is the total number of points equally divided among\n",
      "            clusters.\n",
      "            If array-like, each element of the sequence indicates\n",
      "            the number of samples per cluster.\n",
      "        \n",
      "        n_features : int, optional (default=2)\n",
      "            The number of features for each sample.\n",
      "        \n",
      "        centers : int or array of shape [n_centers, n_features], optional\n",
      "            (default=None)\n",
      "            The number of centers to generate, or the fixed center locations.\n",
      "            If n_samples is an int and centers is None, 3 centers are generated.\n",
      "            If n_samples is array-like, centers must be\n",
      "            either None or an array of length equal to the length of n_samples.\n",
      "        \n",
      "        cluster_std : float or sequence of floats, optional (default=1.0)\n",
      "            The standard deviation of the clusters.\n",
      "        \n",
      "        center_box : pair of floats (min, max), optional (default=(-10.0, 10.0))\n",
      "            The bounding box for each cluster center when centers are\n",
      "            generated at random.\n",
      "        \n",
      "        shuffle : boolean, optional (default=True)\n",
      "            Shuffle the samples.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The generated samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The integer labels for cluster membership of each sample.\n",
      "        \n",
      "        Examples\n",
      "        --------\n",
      "        >>> from sklearn.datasets import make_blobs\n",
      "        >>> X, y = make_blobs(n_samples=10, centers=3, n_features=2,\n",
      "        ...                   random_state=0)\n",
      "        >>> print(X.shape)\n",
      "        (10, 2)\n",
      "        >>> y\n",
      "        array([0, 0, 1, 0, 2, 2, 2, 1, 1, 0])\n",
      "        >>> X, y = make_blobs(n_samples=[3, 3, 4], centers=None, n_features=2,\n",
      "        ...                   random_state=0)\n",
      "        >>> print(X.shape)\n",
      "        (10, 2)\n",
      "        >>> y\n",
      "        array([0, 1, 2, 0, 2, 2, 2, 1, 1, 0])\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_classification: a more intricate variant\n",
      "    \n",
      "    make_checkerboard(shape, n_clusters, noise=0.0, minval=10, maxval=100, shuffle=True, random_state=None)\n",
      "        Generate an array with block checkerboard structure for\n",
      "        biclustering.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        shape : iterable (n_rows, n_cols)\n",
      "            The shape of the result.\n",
      "        \n",
      "        n_clusters : integer or iterable (n_row_clusters, n_column_clusters)\n",
      "            The number of row and column clusters.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise.\n",
      "        \n",
      "        minval : int, optional (default=10)\n",
      "            Minimum value of a bicluster.\n",
      "        \n",
      "        maxval : int, optional (default=100)\n",
      "            Maximum value of a bicluster.\n",
      "        \n",
      "        shuffle : boolean, optional (default=True)\n",
      "            Shuffle the samples.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape `shape`\n",
      "            The generated array.\n",
      "        \n",
      "        rows : array of shape (n_clusters, X.shape[0],)\n",
      "            The indicators for cluster membership of each row.\n",
      "        \n",
      "        cols : array of shape (n_clusters, X.shape[1],)\n",
      "            The indicators for cluster membership of each column.\n",
      "        \n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        \n",
      "        .. [1] Kluger, Y., Basri, R., Chang, J. T., & Gerstein, M. (2003).\n",
      "            Spectral biclustering of microarray data: coclustering genes\n",
      "            and conditions. Genome research, 13(4), 703-716.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_biclusters\n",
      "    \n",
      "    make_circles(n_samples=100, shuffle=True, noise=None, random_state=None, factor=0.8)\n",
      "        Make a large circle containing a smaller circle in 2d.\n",
      "        \n",
      "        A simple toy dataset to visualize clustering and classification\n",
      "        algorithms.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The total number of points generated. If odd, the inner circle will\n",
      "            have one point more than the outer circle.\n",
      "        \n",
      "        shuffle : bool, optional (default=True)\n",
      "            Whether to shuffle the samples.\n",
      "        \n",
      "        noise : double or None (default=None)\n",
      "            Standard deviation of Gaussian noise added to the data.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset shuffling and noise.\n",
      "            Pass an int for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        factor : 0 < double < 1 (default=.8)\n",
      "            Scale factor between inner and outer circle.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 2]\n",
      "            The generated samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The integer labels (0 or 1) for class membership of each sample.\n",
      "    \n",
      "    make_classification(n_samples=100, n_features=20, n_informative=2, n_redundant=2, n_repeated=0, n_classes=2, n_clusters_per_class=2, weights=None, flip_y=0.01, class_sep=1.0, hypercube=True, shift=0.0, scale=1.0, shuffle=True, random_state=None)\n",
      "        Generate a random n-class classification problem.\n",
      "        \n",
      "        This initially creates clusters of points normally distributed (std=1)\n",
      "        about vertices of an ``n_informative``-dimensional hypercube with sides of\n",
      "        length ``2*class_sep`` and assigns an equal number of clusters to each\n",
      "        class. It introduces interdependence between these features and adds\n",
      "        various types of further noise to the data.\n",
      "        \n",
      "        Without shuffling, ``X`` horizontally stacks features in the following\n",
      "        order: the primary ``n_informative`` features, followed by ``n_redundant``\n",
      "        linear combinations of the informative features, followed by ``n_repeated``\n",
      "        duplicates, drawn randomly with replacement from the informative and\n",
      "        redundant features. The remaining features are filled with random noise.\n",
      "        Thus, without shuffling, all useful features are contained in the columns\n",
      "        ``X[:, :n_informative + n_redundant + n_repeated]``.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        n_features : int, optional (default=20)\n",
      "            The total number of features. These comprise ``n_informative``\n",
      "            informative features, ``n_redundant`` redundant features,\n",
      "            ``n_repeated`` duplicated features and\n",
      "            ``n_features-n_informative-n_redundant-n_repeated`` useless features\n",
      "            drawn at random.\n",
      "        \n",
      "        n_informative : int, optional (default=2)\n",
      "            The number of informative features. Each class is composed of a number\n",
      "            of gaussian clusters each located around the vertices of a hypercube\n",
      "            in a subspace of dimension ``n_informative``. For each cluster,\n",
      "            informative features are drawn independently from  N(0, 1) and then\n",
      "            randomly linearly combined within each cluster in order to add\n",
      "            covariance. The clusters are then placed on the vertices of the\n",
      "            hypercube.\n",
      "        \n",
      "        n_redundant : int, optional (default=2)\n",
      "            The number of redundant features. These features are generated as\n",
      "            random linear combinations of the informative features.\n",
      "        \n",
      "        n_repeated : int, optional (default=0)\n",
      "            The number of duplicated features, drawn randomly from the informative\n",
      "            and the redundant features.\n",
      "        \n",
      "        n_classes : int, optional (default=2)\n",
      "            The number of classes (or labels) of the classification problem.\n",
      "        \n",
      "        n_clusters_per_class : int, optional (default=2)\n",
      "            The number of clusters per class.\n",
      "        \n",
      "        weights : array-like of shape (n_classes,) or (n_classes - 1,),              (default=None)\n",
      "            The proportions of samples assigned to each class. If None, then\n",
      "            classes are balanced. Note that if ``len(weights) == n_classes - 1``,\n",
      "            then the last class weight is automatically inferred.\n",
      "            More than ``n_samples`` samples may be returned if the sum of\n",
      "            ``weights`` exceeds 1.\n",
      "        \n",
      "        flip_y : float, optional (default=0.01)\n",
      "            The fraction of samples whose class is assigned randomly. Larger\n",
      "            values introduce noise in the labels and make the classification\n",
      "            task harder.\n",
      "        \n",
      "        class_sep : float, optional (default=1.0)\n",
      "            The factor multiplying the hypercube size.  Larger values spread\n",
      "            out the clusters/classes and make the classification task easier.\n",
      "        \n",
      "        hypercube : boolean, optional (default=True)\n",
      "            If True, the clusters are put on the vertices of a hypercube. If\n",
      "            False, the clusters are put on the vertices of a random polytope.\n",
      "        \n",
      "        shift : float, array of shape [n_features] or None, optional (default=0.0)\n",
      "            Shift features by the specified value. If None, then features\n",
      "            are shifted by a random value drawn in [-class_sep, class_sep].\n",
      "        \n",
      "        scale : float, array of shape [n_features] or None, optional (default=1.0)\n",
      "            Multiply features by the specified value. If None, then features\n",
      "            are scaled by a random value drawn in [1, 100]. Note that scaling\n",
      "            happens after shifting.\n",
      "        \n",
      "        shuffle : boolean, optional (default=True)\n",
      "            Shuffle the samples and the features.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The generated samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The integer labels for class membership of each sample.\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        The algorithm is adapted from Guyon [1] and was designed to generate\n",
      "        the \"Madelon\" dataset.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] I. Guyon, \"Design of experiments for the NIPS 2003 variable\n",
      "               selection benchmark\", 2003.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_blobs: simplified variant\n",
      "        make_multilabel_classification: unrelated generator for multilabel tasks\n",
      "    \n",
      "    make_friedman1(n_samples=100, n_features=10, noise=0.0, random_state=None)\n",
      "        Generate the \"Friedman #1\" regression problem\n",
      "        \n",
      "        This dataset is described in Friedman [1] and Breiman [2].\n",
      "        \n",
      "        Inputs `X` are independent features uniformly distributed on the interval\n",
      "        [0, 1]. The output `y` is created according to the formula::\n",
      "        \n",
      "            y(X) = 10 * sin(pi * X[:, 0] * X[:, 1]) + 20 * (X[:, 2] - 0.5) ** 2 + 10 * X[:, 3] + 5 * X[:, 4] + noise * N(0, 1).\n",
      "        \n",
      "        Out of the `n_features` features, only 5 are actually used to compute\n",
      "        `y`. The remaining features are independent of `y`.\n",
      "        \n",
      "        The number of features has to be >= 5.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        n_features : int, optional (default=10)\n",
      "            The number of features. Should be at least 5.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise applied to the output.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset noise. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The input samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The output values.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] J. Friedman, \"Multivariate adaptive regression splines\", The Annals\n",
      "               of Statistics 19 (1), pages 1-67, 1991.\n",
      "        \n",
      "        .. [2] L. Breiman, \"Bagging predictors\", Machine Learning 24,\n",
      "               pages 123-140, 1996.\n",
      "    \n",
      "    make_friedman2(n_samples=100, noise=0.0, random_state=None)\n",
      "        Generate the \"Friedman #2\" regression problem\n",
      "        \n",
      "        This dataset is described in Friedman [1] and Breiman [2].\n",
      "        \n",
      "        Inputs `X` are 4 independent features uniformly distributed on the\n",
      "        intervals::\n",
      "        \n",
      "            0 <= X[:, 0] <= 100,\n",
      "            40 * pi <= X[:, 1] <= 560 * pi,\n",
      "            0 <= X[:, 2] <= 1,\n",
      "            1 <= X[:, 3] <= 11.\n",
      "        \n",
      "        The output `y` is created according to the formula::\n",
      "        \n",
      "            y(X) = (X[:, 0] ** 2 + (X[:, 1] * X[:, 2]  - 1 / (X[:, 1] * X[:, 3])) ** 2) ** 0.5 + noise * N(0, 1).\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise applied to the output.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset noise. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 4]\n",
      "            The input samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The output values.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] J. Friedman, \"Multivariate adaptive regression splines\", The Annals\n",
      "               of Statistics 19 (1), pages 1-67, 1991.\n",
      "        \n",
      "        .. [2] L. Breiman, \"Bagging predictors\", Machine Learning 24,\n",
      "               pages 123-140, 1996.\n",
      "    \n",
      "    make_friedman3(n_samples=100, noise=0.0, random_state=None)\n",
      "        Generate the \"Friedman #3\" regression problem\n",
      "        \n",
      "        This dataset is described in Friedman [1] and Breiman [2].\n",
      "        \n",
      "        Inputs `X` are 4 independent features uniformly distributed on the\n",
      "        intervals::\n",
      "        \n",
      "            0 <= X[:, 0] <= 100,\n",
      "            40 * pi <= X[:, 1] <= 560 * pi,\n",
      "            0 <= X[:, 2] <= 1,\n",
      "            1 <= X[:, 3] <= 11.\n",
      "        \n",
      "        The output `y` is created according to the formula::\n",
      "        \n",
      "            y(X) = arctan((X[:, 1] * X[:, 2] - 1 / (X[:, 1] * X[:, 3])) / X[:, 0]) + noise * N(0, 1).\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise applied to the output.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset noise. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 4]\n",
      "            The input samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The output values.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] J. Friedman, \"Multivariate adaptive regression splines\", The Annals\n",
      "               of Statistics 19 (1), pages 1-67, 1991.\n",
      "        \n",
      "        .. [2] L. Breiman, \"Bagging predictors\", Machine Learning 24,\n",
      "               pages 123-140, 1996.\n",
      "    \n",
      "    make_gaussian_quantiles(mean=None, cov=1.0, n_samples=100, n_features=2, n_classes=3, shuffle=True, random_state=None)\n",
      "        Generate isotropic Gaussian and label samples by quantile\n",
      "        \n",
      "        This classification dataset is constructed by taking a multi-dimensional\n",
      "        standard normal distribution and defining classes separated by nested\n",
      "        concentric multi-dimensional spheres such that roughly equal numbers of\n",
      "        samples are in each class (quantiles of the :math:`\\chi^2` distribution).\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        mean : array of shape [n_features], optional (default=None)\n",
      "            The mean of the multi-dimensional normal distribution.\n",
      "            If None then use the origin (0, 0, ...).\n",
      "        \n",
      "        cov : float, optional (default=1.)\n",
      "            The covariance matrix will be this value times the unit matrix. This\n",
      "            dataset only produces symmetric normal distributions.\n",
      "        \n",
      "        n_samples : int, optional (default=100)\n",
      "            The total number of points equally divided among classes.\n",
      "        \n",
      "        n_features : int, optional (default=2)\n",
      "            The number of features for each sample.\n",
      "        \n",
      "        n_classes : int, optional (default=3)\n",
      "            The number of classes\n",
      "        \n",
      "        shuffle : boolean, optional (default=True)\n",
      "            Shuffle the samples.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The generated samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The integer labels for quantile membership of each sample.\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        The dataset is from Zhu et al [1].\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] J. Zhu, H. Zou, S. Rosset, T. Hastie, \"Multi-class AdaBoost\", 2009.\n",
      "    \n",
      "    make_hastie_10_2(n_samples=12000, random_state=None)\n",
      "        Generates data for binary classification used in\n",
      "        Hastie et al. 2009, Example 10.2.\n",
      "        \n",
      "        The ten features are standard independent Gaussian and\n",
      "        the target ``y`` is defined by::\n",
      "        \n",
      "          y[i] = 1 if np.sum(X[i] ** 2) > 9.34 else -1\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=12000)\n",
      "            The number of samples.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 10]\n",
      "            The input samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The output values.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] T. Hastie, R. Tibshirani and J. Friedman, \"Elements of Statistical\n",
      "               Learning Ed. 2\", Springer, 2009.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_gaussian_quantiles: a generalization of this dataset approach\n",
      "    \n",
      "    make_low_rank_matrix(n_samples=100, n_features=100, effective_rank=10, tail_strength=0.5, random_state=None)\n",
      "        Generate a mostly low rank matrix with bell-shaped singular values\n",
      "        \n",
      "        Most of the variance can be explained by a bell-shaped curve of width\n",
      "        effective_rank: the low rank part of the singular values profile is::\n",
      "        \n",
      "            (1 - tail_strength) * exp(-1.0 * (i / effective_rank) ** 2)\n",
      "        \n",
      "        The remaining singular values' tail is fat, decreasing as::\n",
      "        \n",
      "            tail_strength * exp(-0.1 * i / effective_rank).\n",
      "        \n",
      "        The low rank part of the profile can be considered the structured\n",
      "        signal part of the data while the tail can be considered the noisy\n",
      "        part of the data that cannot be summarized by a low number of linear\n",
      "        components (singular vectors).\n",
      "        \n",
      "        This kind of singular profiles is often seen in practice, for instance:\n",
      "         - gray level pictures of faces\n",
      "         - TF-IDF vectors of text documents crawled from the web\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        n_features : int, optional (default=100)\n",
      "            The number of features.\n",
      "        \n",
      "        effective_rank : int, optional (default=10)\n",
      "            The approximate number of singular vectors required to explain most of\n",
      "            the data by linear combinations.\n",
      "        \n",
      "        tail_strength : float between 0.0 and 1.0, optional (default=0.5)\n",
      "            The relative importance of the fat noisy tail of the singular values\n",
      "            profile.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The matrix.\n",
      "    \n",
      "    make_moons(n_samples=100, shuffle=True, noise=None, random_state=None)\n",
      "        Make two interleaving half circles\n",
      "        \n",
      "        A simple toy dataset to visualize clustering and classification\n",
      "        algorithms. Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The total number of points generated.\n",
      "        \n",
      "        shuffle : bool, optional (default=True)\n",
      "            Whether to shuffle the samples.\n",
      "        \n",
      "        noise : double or None (default=None)\n",
      "            Standard deviation of Gaussian noise added to the data.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset shuffling and noise.\n",
      "            Pass an int for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 2]\n",
      "            The generated samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The integer labels (0 or 1) for class membership of each sample.\n",
      "    \n",
      "    make_multilabel_classification(n_samples=100, n_features=20, n_classes=5, n_labels=2, length=50, allow_unlabeled=True, sparse=False, return_indicator='dense', return_distributions=False, random_state=None)\n",
      "        Generate a random multilabel classification problem.\n",
      "        \n",
      "        For each sample, the generative process is:\n",
      "            - pick the number of labels: n ~ Poisson(n_labels)\n",
      "            - n times, choose a class c: c ~ Multinomial(theta)\n",
      "            - pick the document length: k ~ Poisson(length)\n",
      "            - k times, choose a word: w ~ Multinomial(theta_c)\n",
      "        \n",
      "        In the above process, rejection sampling is used to make sure that\n",
      "        n is never zero or more than `n_classes`, and that the document length\n",
      "        is never zero. Likewise, we reject classes which have already been chosen.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        n_features : int, optional (default=20)\n",
      "            The total number of features.\n",
      "        \n",
      "        n_classes : int, optional (default=5)\n",
      "            The number of classes of the classification problem.\n",
      "        \n",
      "        n_labels : int, optional (default=2)\n",
      "            The average number of labels per instance. More precisely, the number\n",
      "            of labels per sample is drawn from a Poisson distribution with\n",
      "            ``n_labels`` as its expected value, but samples are bounded (using\n",
      "            rejection sampling) by ``n_classes``, and must be nonzero if\n",
      "            ``allow_unlabeled`` is False.\n",
      "        \n",
      "        length : int, optional (default=50)\n",
      "            The sum of the features (number of words if documents) is drawn from\n",
      "            a Poisson distribution with this expected value.\n",
      "        \n",
      "        allow_unlabeled : bool, optional (default=True)\n",
      "            If ``True``, some instances might not belong to any class.\n",
      "        \n",
      "        sparse : bool, optional (default=False)\n",
      "            If ``True``, return a sparse feature matrix\n",
      "        \n",
      "            .. versionadded:: 0.17\n",
      "               parameter to allow *sparse* output.\n",
      "        \n",
      "        return_indicator : 'dense' (default) | 'sparse' | False\n",
      "            If ``dense`` return ``Y`` in the dense binary indicator format. If\n",
      "            ``'sparse'`` return ``Y`` in the sparse binary indicator format.\n",
      "            ``False`` returns a list of lists of labels.\n",
      "        \n",
      "        return_distributions : bool, optional (default=False)\n",
      "            If ``True``, return the prior class probability and conditional\n",
      "            probabilities of features given classes, from which the data was\n",
      "            drawn.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The generated samples.\n",
      "        \n",
      "        Y : array or sparse CSR matrix of shape [n_samples, n_classes]\n",
      "            The label sets.\n",
      "        \n",
      "        p_c : array, shape [n_classes]\n",
      "            The probability of each class being drawn. Only returned if\n",
      "            ``return_distributions=True``.\n",
      "        \n",
      "        p_w_c : array, shape [n_features, n_classes]\n",
      "            The probability of each feature being drawn given each class.\n",
      "            Only returned if ``return_distributions=True``.\n",
      "    \n",
      "    make_regression(n_samples=100, n_features=100, n_informative=10, n_targets=1, bias=0.0, effective_rank=None, tail_strength=0.5, noise=0.0, shuffle=True, coef=False, random_state=None)\n",
      "        Generate a random regression problem.\n",
      "        \n",
      "        The input set can either be well conditioned (by default) or have a low\n",
      "        rank-fat tail singular profile. See :func:`make_low_rank_matrix` for\n",
      "        more details.\n",
      "        \n",
      "        The output is generated by applying a (potentially biased) random linear\n",
      "        regression model with `n_informative` nonzero regressors to the previously\n",
      "        generated input and some gaussian centered noise with some adjustable\n",
      "        scale.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        n_features : int, optional (default=100)\n",
      "            The number of features.\n",
      "        \n",
      "        n_informative : int, optional (default=10)\n",
      "            The number of informative features, i.e., the number of features used\n",
      "            to build the linear model used to generate the output.\n",
      "        \n",
      "        n_targets : int, optional (default=1)\n",
      "            The number of regression targets, i.e., the dimension of the y output\n",
      "            vector associated with a sample. By default, the output is a scalar.\n",
      "        \n",
      "        bias : float, optional (default=0.0)\n",
      "            The bias term in the underlying linear model.\n",
      "        \n",
      "        effective_rank : int or None, optional (default=None)\n",
      "            if not None:\n",
      "                The approximate number of singular vectors required to explain most\n",
      "                of the input data by linear combinations. Using this kind of\n",
      "                singular spectrum in the input allows the generator to reproduce\n",
      "                the correlations often observed in practice.\n",
      "            if None:\n",
      "                The input set is well conditioned, centered and gaussian with\n",
      "                unit variance.\n",
      "        \n",
      "        tail_strength : float between 0.0 and 1.0, optional (default=0.5)\n",
      "            The relative importance of the fat noisy tail of the singular values\n",
      "            profile if `effective_rank` is not None.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise applied to the output.\n",
      "        \n",
      "        shuffle : boolean, optional (default=True)\n",
      "            Shuffle the samples and the features.\n",
      "        \n",
      "        coef : boolean, optional (default=False)\n",
      "            If True, the coefficients of the underlying linear model are returned.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The input samples.\n",
      "        \n",
      "        y : array of shape [n_samples] or [n_samples, n_targets]\n",
      "            The output values.\n",
      "        \n",
      "        coef : array of shape [n_features] or [n_features, n_targets], optional\n",
      "            The coefficient of the underlying linear model. It is returned only if\n",
      "            coef is True.\n",
      "    \n",
      "    make_s_curve(n_samples=100, noise=0.0, random_state=None)\n",
      "        Generate an S curve dataset.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of sample points on the S curve.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 3]\n",
      "            The points.\n",
      "        \n",
      "        t : array of shape [n_samples]\n",
      "            The univariate position of the sample according to the main dimension\n",
      "            of the points in the manifold.\n",
      "    \n",
      "    make_sparse_coded_signal(n_samples, n_components, n_features, n_nonzero_coefs, random_state=None)\n",
      "        Generate a signal as a sparse combination of dictionary elements.\n",
      "        \n",
      "        Returns a matrix Y = DX, such as D is (n_features, n_components),\n",
      "        X is (n_components, n_samples) and each column of X has exactly\n",
      "        n_nonzero_coefs non-zero elements.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int\n",
      "            number of samples to generate\n",
      "        \n",
      "        n_components :  int,\n",
      "            number of components in the dictionary\n",
      "        \n",
      "        n_features : int\n",
      "            number of features of the dataset to generate\n",
      "        \n",
      "        n_nonzero_coefs : int\n",
      "            number of active (non-zero) coefficients in each sample\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        data : array of shape [n_features, n_samples]\n",
      "            The encoded signal (Y).\n",
      "        \n",
      "        dictionary : array of shape [n_features, n_components]\n",
      "            The dictionary with normalized components (D).\n",
      "        \n",
      "        code : array of shape [n_components, n_samples]\n",
      "            The sparse code such that each column of this matrix has exactly\n",
      "            n_nonzero_coefs non-zero items (X).\n",
      "    \n",
      "    make_sparse_spd_matrix(dim=1, alpha=0.95, norm_diag=False, smallest_coef=0.1, largest_coef=0.9, random_state=None)\n",
      "        Generate a sparse symmetric definite positive matrix.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        dim : integer, optional (default=1)\n",
      "            The size of the random matrix to generate.\n",
      "        \n",
      "        alpha : float between 0 and 1, optional (default=0.95)\n",
      "            The probability that a coefficient is zero (see notes). Larger values\n",
      "            enforce more sparsity.\n",
      "        \n",
      "        norm_diag : boolean, optional (default=False)\n",
      "            Whether to normalize the output matrix to make the leading diagonal\n",
      "            elements all 1\n",
      "        \n",
      "        smallest_coef : float between 0 and 1, optional (default=0.1)\n",
      "            The value of the smallest coefficient.\n",
      "        \n",
      "        largest_coef : float between 0 and 1, optional (default=0.9)\n",
      "            The value of the largest coefficient.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        prec : sparse matrix of shape (dim, dim)\n",
      "            The generated matrix.\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        The sparsity is actually imposed on the cholesky factor of the matrix.\n",
      "        Thus alpha does not translate directly into the filling fraction of\n",
      "        the matrix itself.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_spd_matrix\n",
      "    \n",
      "    make_sparse_uncorrelated(n_samples=100, n_features=10, random_state=None)\n",
      "        Generate a random regression problem with sparse uncorrelated design\n",
      "        \n",
      "        This dataset is described in Celeux et al [1]. as::\n",
      "        \n",
      "            X ~ N(0, 1)\n",
      "            y(X) = X[:, 0] + 2 * X[:, 1] - 2 * X[:, 2] - 1.5 * X[:, 3]\n",
      "        \n",
      "        Only the first 4 features are informative. The remaining features are\n",
      "        useless.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of samples.\n",
      "        \n",
      "        n_features : int, optional (default=10)\n",
      "            The number of features.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, n_features]\n",
      "            The input samples.\n",
      "        \n",
      "        y : array of shape [n_samples]\n",
      "            The output values.\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] G. Celeux, M. El Anbari, J.-M. Marin, C. P. Robert,\n",
      "               \"Regularization in regression: comparing Bayesian and frequentist\n",
      "               methods in a poorly informative situation\", 2009.\n",
      "    \n",
      "    make_spd_matrix(n_dim, random_state=None)\n",
      "        Generate a random symmetric, positive-definite matrix.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_dim : int\n",
      "            The matrix dimension.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_dim, n_dim]\n",
      "            The random symmetric, positive-definite matrix.\n",
      "        \n",
      "        See also\n",
      "        --------\n",
      "        make_sparse_spd_matrix\n",
      "    \n",
      "    make_swiss_roll(n_samples=100, noise=0.0, random_state=None)\n",
      "        Generate a swiss roll dataset.\n",
      "        \n",
      "        Read more in the :ref:`User Guide <sample_generators>`.\n",
      "        \n",
      "        Parameters\n",
      "        ----------\n",
      "        n_samples : int, optional (default=100)\n",
      "            The number of sample points on the S curve.\n",
      "        \n",
      "        noise : float, optional (default=0.0)\n",
      "            The standard deviation of the gaussian noise.\n",
      "        \n",
      "        random_state : int, RandomState instance or None (default)\n",
      "            Determines random number generation for dataset creation. Pass an int\n",
      "            for reproducible output across multiple function calls.\n",
      "            See :term:`Glossary <random_state>`.\n",
      "        \n",
      "        Returns\n",
      "        -------\n",
      "        X : array of shape [n_samples, 3]\n",
      "            The points.\n",
      "        \n",
      "        t : array of shape [n_samples]\n",
      "            The univariate position of the sample according to the main dimension\n",
      "            of the points in the manifold.\n",
      "        \n",
      "        Notes\n",
      "        -----\n",
      "        The algorithm is from Marsland [1].\n",
      "        \n",
      "        References\n",
      "        ----------\n",
      "        .. [1] S. Marsland, \"Machine Learning: An Algorithmic Perspective\",\n",
      "               Chapter 10, 2009.\n",
      "               http://seat.massey.ac.nz/personal/s.r.marsland/Code/10/lle.py\n",
      "\n",
      "DATA\n",
      "    __all__ = ['clear_data_home', 'dump_svmlight_file', 'fetch_20newsgroup...\n",
      "\n",
      "FILE\n",
      "    /Users/aaron/opt/anaconda3/lib/python3.7/site-packages/sklearn/datasets/__init__.py\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(datasets)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define features and targets\n",
    "diabetes_X = diabetes.data[:, np.newaxis, 2]\n",
    "diabetes_Y = diabetes.target"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(diabetes_X, diabetes_Y, '.')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "#from importlib import reload\n",
    "#reload(my_module)\n",
    "sr = my_module.SimpleRegression()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "sr.fit(diabetes_X, diabetes_Y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "949.4352603839488\n",
      "152.1334841628967\n"
     ]
    }
   ],
   "source": [
    "print(sr.coef_)\n",
    "print(sr.intercept_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXcAAAD4CAYAAAAXUaZHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjMsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+AADFEAAAgAElEQVR4nO2deZgcVbn/P2/PJJFoJENYEshGBKImKmQiBFEkgAgIRAlIgKuAQNQbxO2qKNeYi6Jcrwt45ScGvAqahZAEg0gQAmGJMiEzI0sihoQhy5gAJgyLBjNLn98fXdVTXVPVXVVd3V3d/X6eZ56ZPl3LOdXT3/Oe97znPWKMQVEURaktUpWugKIoihI/Ku6Koig1iIq7oihKDaLiriiKUoOouCuKotQgjZWuAMD+++9vxo8fX+lqKIqiVBVtbW27jDEHeL2XCHEfP348ra2tla6GoihKVSEiW/3eU7eMoihKDaLiriiKUoOouCuKotQgBcVdRN4kIo+LyJMiskFE/ssq/5WIPC8iT1g/R1rlIiI/EZHNIvKUiEwpdSMURVGUXIJMqO4FTjTG/ENEBgFrRGSl9d5XjDFLXcefBhxu/RwD/Mz6rSiKopSJgpa7yfAP6+Ug6ydftrEZwG3WeS3AcBEZVXxVFUVRlKAE8rmLSIOIPAG8BNxvjFlrvXWt5Xr5sYgMscoOAbY7Tu+0ytzXnC0irSLS+ve//72IJiiKoiSDtq1d3Lh6M21buypdlWDibozpM8YcCYwGjhaRycDXgbcD7wX2A75mHS5el/C45nxjzFRjzNQDDvCMwVcURaka2rZ2ceEtLfzwvo1ceEtLxQU+VLSMMeYV4CHgVGPMTsv1shf4JXC0dVgnMMZx2mhgRwx1VRRFSSwtHbvp7k2TNtDTm6alY3dF6xMkWuYAERlu/b0PcDLwV9uPLiICfBRYb51yF/BJK2pmGvCqMWZnSWqvKErdkCSXhxfTJoxgcGOKBoFBjSmmTRhR0foEiZYZBdwqIg1kOoMlxpi7ReRBETmAjBvmCeAz1vH3AKcDm4E9wCXxV1tRlHrCdnl096YZ3JhiwWXTaB7XVOlq5dA8rokFl02jpWM30yaMqHj9Coq7MeYp4CiP8hN9jjfAnOKrpiiKksHL5VFp8fSieVxTYuqlK1QVRSkLxbhVkubyqAYSkRVSUZTapli3StJcHtWAiruiKCUnDrdKklwe1YC6ZRSlBtBIEsWNWu6KUuVoJInihYq7olQ5GkmieKFuGUWpctTloXihlruiVDnq8lC8UHFXlBpAXR6KG3XLKIqi1CAq7oqixELSwzHrDXXLKIpSNNUQjllvqOWuKEWg1mqGpOUyV9RyV5TIqLXajx2O2dOb1nDMhKDirigRqZbFQ+VAwzGTh4q7okRErdVcNBwzBMbAPV+BdTfD+66EU74d+y1U3JWK0ba1K7GWXpC6hbFWk9rWpNarZnGKus2B7yzJrVTclYqQZH91mLoFsVaT2tak1qsm8RL10UfDJ1fA4KEluaVGyygVIcnRFXHXLaltTWq9ClFVEUrGwD1fhf8a3i/so4+Gb+yEy+4vmbCDWu5KhUiyvzruuiWprU43TJLqFZSqGW0YA/d+Hdb+rL/skKlw0V0w+M1lqYJk9rOuLFOnTjWtra2VroZSZpLs7427bkloq5cwAhWvVxhuXL2ZH963kbSBBoEvnTKROdMPq3S1+imzqItImzFmqtd7BS13EXkT8AgwxDp+qTHmWyJyKLAY2A9oBz5hjOkWkSHAbUAzsBs4zxizJZaWKDVFOaMrwoprLUZ+eLlh5kw/rKramdjRhjHwh6uh5cb+soOnwMV3l81SdxPELbMXONEY8w8RGQSsEZGVwJeAHxtjFovITcClwM+s313GmMNEZBbw38B5Jaq/ohSk0kP5St/fJrHCGILExdMnUNRtCoq7yfht/mG9HGT9GOBE4AKr/FZgHhlxn2H9DbAU+KmIiEmC/0epSyq92KjS97dJnDBGJBGjKmPgvv+Ex37aXzbqSLj49zDkLZWrl4NAE6oi0gC0AYcBNwLPAa8YY3qtQzqBQ6y/DwG2AxhjekXkVWAEsCvGeit1RLH+6kpbrJW+v5NECGM14ynq74GL70mMqNsEEndjTB9wpIgMB+4E3uF1mPVb8ryXRURmA7MBxo4dG6iySv0Rh0vDy2It5wRnrVjMdY0xcP9c+NNP+stGvhsuuQeGDKtcvfIQKhTSGPOKiDwETAOGi0ijZb2PBnZYh3UCY4BOEWkE9gVe9rjWfGA+ZKJlIrdAqWnicmk4LdZK+MDjspiTEHVTV3iJ+kHvgk+tTKyo2wSJljkA6LGEfR/gZDKTpKuBc8hEzFwErLBOuct6/Zj1/oPqb69+oopKEl0q5fSBxynGSZmYrQuMgVXz4I/X95dViajbBLHcRwG3Wn73FLDEGHO3iPwFWCwi3wH+DPzCOv4XwK9FZDMZi31WCeqtlJGoolIql0qxlMsHHrcYJ2VitqbxEvUDJ8Gn7oU3vbVi1YpCkGiZp4CjPMo7gKM9yv8FnBtL7ZREEFVUSuFSiYNy+cDjFuMkTczWHMbAA9fAmh/1l1WpqNto+gGlIFFFJcliVI6okVK0/+wpoxHrt1rtMeAl6ge8Ay69r2pF3UbTDyiBqJTPvdqJq/3qb48ZY+DB78CjP+gvq0JRLyr9gKJAdEu33uOq42q/+ttjwkvU95+YydD4pn0rV68SoOKuxEISLfQk1ikqSXZxVQ2rvwsP/3f/6xoVdRsV9zonDgGstMvAqw2VrlMY4t71qZaIpYNe/T14+Lr+1yMOh8tWwT7D46lkQlFxr2PiEsBKugz82lCJOkURorh3faoliv7/fOg6eOh7/a/rRNRtVNzrmLgEsJIuA782lLtOUYWo0r70JLuuIj+bh/4bHvpu/+v93gaXP1g3om6j4l7HxCWAxboM/NwqQa7n14ZyuzGiClHQz6AUIpx011Xo/08V9RxU3OuYOAUwqsvAb3egMK4KvzaU040RRojcQl3oM/AT4batXSxv78QAMyPEvYfpkCph4Qf+/3z4f2D1d/pfNx0Ks1fDPsnpqCqBinudU2k/rt8mzYVExy02lbY4gwqRn1Dnq7/fMzr/5sx1AJa2bmfR7GNDPYegHdLCtduYu2I9aWPKbuHnfTZuUR8+Dj79cN2Luo2Ku1JR/AQmn+gkwZ3gZcnmEyL7+L+98kZo943XM2rp2E2PJewAPX0mtL8+6Khh7or19KYzix27kxBj/8gP4MFv978ePg5mPwRD96tUjRKJirtSUfwEJp/oxDkJWeoIF/fxjQ0pGlNCX9oEnufwe0aDGlNZy31Qg0SaMwkyauhL969iT4n/fUruunGL+r5jM5a6ironKu5KxfESGD/Radvaxd9eeYPGhhR9fcVNBJcrwsV5fF9fmllHj8XgvauNH+7n0TyuiUWXTyvK5x6EaRNGMGRQiu6eNKmUcM2MyaHmBWLh0R/BA//V/1pFPRAq7krVkGMBp4RZR48tKoFWqSNc/I6fdPC+XHP3Brp70yxr74wshOWYawg6l1CSkE63qL91NHzmURX1gKi4K1WDU0B6+wzbXt6T877tFmgaOpiuPd2RwygLETbKyH18pWPbwxKkE4l1XcGa62HVt/pfq6hHQsVdqRpsAenuSZMG/rh5F+u2vJwTPrm3J40BUkJRYZSFCGs1u49vTAk9fYaGVDRfeVz4+cnD+s9jCat1i/qwg+Eza+DNmkcnCiruSiyUIw7aFpDrVz3LHzfvIm0y0RvXr3qWMfsNpbs3nd2JPahVXLEwShHAWL8rQ774+Sj+88jP8o8/gfu/2f9aRT0WVNyVoilnaGLzuCa+cPIRrNvycta1sWbTLgY1ZqJQevsMaTKWe1KzJ7Z07Ka3L9MR9fWVPxdPIfdQ2dxGf/op3Hd1/+u3jITP/hHevH/896pDVNyVoikkBm1bu1jW3hnbDkJOC37Npl1ZkZx19FgOHr5PYJ97HEQZsRSzmrXYujo74blnTPKsR9x5eQa0ISZRT3JenCSg4q5EwvnFyicGbVu7OH/+Y3T3ZRwmd7R1sujy4i17pwVv37fcW88V474oZjVr0Lq5r+/uhLv2dHvWI860FM42XD5oJc2pX/e/+eYD4bN/grccUNR1k5gXJwmouCuh8fpi+YlBS8duevr6F8HEOcyPU4SiUIz7Ioh/Our1/YTPqxP2q0dccxEtHbu50Pyebw6JR9Sd162miKNKoOKuhMbrizVn+mGeX65pE0YwqEGylnvcfvBK5pUpdVrhqNf3E76yd4YtP2POw1dlVWa3eSud5z/Ie95+eNGX1p2pClNQ3EVkDHAbMBJIA/ONMTeIyDzgcuDv1qHfMMbcY53zdeBSoA+40hjzhxLUPbGU0hdYzLXjqleYL1bzuCYWzT42Vp97Uii1WHpdP8hnmO/zKUtn2HIT3Pu17MueIfvx6ymLec/bj4jt3pUetVUDYozJf4DIKGCUMaZdRIYBbcBHgY8D/zDG/MB1/DuBRcDRwMHAKuAIY0yf3z2mTp1qWltbi2pIUiilL7BYH2yc9dLJrPIT5jOsyOez9uew8qv9r/fZD+ashbccWJ771yEi0maMmer1XkHL3RizE9hp/f26iDwDHJLnlBnAYmPMXuB5EdlMRugfC13zKqSUvsBirh13veKwALWDCEeYz7Cs7qq182HlV/pfv2k4zHkchh1UnvsrnoTyuYvIeOAoYC1wHHCFiHwSaAW+bIzpIiP8LY7TOvHoDERkNjAbYOzYsRGqnkxK6Qss5tqlqldUgS52JFGqnYmS3Nkkzs/8+M1wz3/0v1ZRTxQF3TLZA0XeAjwMXGuMWS4iBwG7AAN8m4zr5lMiciPwmDHmN9Z5vwDuMcYs87t2LblloPZ97s7rhRVoZ17zxY9vI22gQeBLp0xkzvTDIt137hmTio5rL8U1g9wzSrrhindAblEfsi9c8TgMG1mZ+tQxRbllrAsMApYBC4wxywGMMS863r8ZuNt62QmMcZw+GtgRod5VSymHxMVcO+56hXX1FJvX3Ou+3b3pULsE+YljzjV7wl0zCmVf4h8H626B33+5/7WKeqIJEi0jwC+AZ4wxP3KUj7L88QAfA9Zbf98FLBSRH5GZUD0ceDzWWiuJIKybwCuv+cHD9wlshTqzPtr3Fcl0EIZg+4D6CaqzLSJC2piSxlC3dOzOJjnb25PJj/OFk+OLJokVl6h3N7yZv57zIO9+x9srWKnaoJQjsSCW+3HAJ4CnReQJq+wbwPkiciQZt8wW4NMAxpgNIrIE+AvQC8zJFymjVJ6o/2Bhw9HcnUGYsEg/t0nT0MFcc/eGQB1MvpGGsy1hrhmVpqGDs0nODJn8OHaGy8QIfOv/wd1fzL7sG/QWpv/r+3TuHc7ghc+z4LKDklPXKqTUq2yDRMuswXvTmHvynHMtcG0R9VLKRLH/YGHcBMXEJnstnbd99BNHDgt0zUIjDWdbgl4zKl17uklJJnslEGjkUTZafwl3f6H/9aA3w+daualtD533bdRVoTFR6lW2ukK1zin3Mu6oPmM/YQ4z6gjTuZTat53NTW89+xQJyGLZ9iv43ef7X1uizlsPBmDahK7YonUSMTFcYUod/RQ4WqaU1Fq0TDVhW+72P1ii3AIu3IIQ17C2UkITdueo0lXkVvjdlf2vG/eBz7XBvgOXs8TxrDTpVz/FPs+io2WU2iVpy7id/+xATr3c1nQco45KCk1FI18A2m+Duz7X/zqPqNvEUWdN+tVPKf8HVNyVxOAOlcQYetP+4YjuYW3T0MHcuHpzqE6qmMyLSekQnQSqV/uv4a4r+l83DIEr22Hf0WWpY7kXYyX1syo1Ku51TpKGyG6hhfwTjV4RLmHbEUVokvTMQtWrwqJuU87RYlI/q3Kg4l7nxDlEzmchhc1m2GBZ7oUWOdnD2htXb47UjihCE2TnqUpYir71+vMCWPHv/QemBsGVf4bhY/wvVmLK5ZKqZxeQinudE9cQOZ+FFNR6cgstEFgki2lHWKEptPNUpSxFd70+0vcgzGvuPyDVCFc+UVFRLzeJy8dTRlTc65y4hsj5LKRishmWI4Y+LPnuVUlL0a5X159+xckb58Ea6w1pgM8/AcNrJ0FfUJIWMFBOVNyVWIbI+SykOK2nfC4Pv3aUwk3id6+KWopPLKL5t59xFAh8/kloGle+OiSQikclVQiNc1dio1ife5DrR8lCWW43Sdl97k8uhjs/7ShQUa8XNM5dKQv5LKRKxUe7z1nW3lmWdMxB0xcXxZO3w52zc8s+/5SKugKouCsWxVqb5chh78wGGdTlkROBkxKWtnXS2xf/NnWlHiE4n8EBz/+WD/31m7kHfP5JaBof2/2U6kfFXYllV6Ry7RsbdhMN54TajlfeYJG1QUg+yz9Ke0o5kWrX59S+R7h+8P/LffPKJ2C/Q2O5j1JbpCpdAaXyeAmTk7atXdy4ejNtW7sCnb+svTPv8cXUzc4GGTZz5Zzph3H2lNEMbkzRIPmTdBV6Hl7YI4RC186H33Pe3bKAvzbMyhH2E/b+mBs/2KbCrviilrtSdNx2VNdHsXULS9CwuCj3jBJy586jM+A5v/YALLuUUxznHL/3x3RyEIPrLGZbCY+Ke0iSmqeimHo1j2ti7hmTWLl+J6dNHhU6bjuK6yNM3eKMUw4ysRv1nmEmjd2d5tlTRmef8ynpP9L8y1k5xz8982Ee2fUWPlPpDJJK1aDiHoKk5qmIw2du52VZt+VlJo4clj0/qBVrC1vb1i6WtXfGGuftFM1yda6ljo12d5oCnDVoLdenbsg98HPtMOJtvAt4V8lqo9QiKu4hSGqeimLrFXT7ubg3xPCiUKx8EjvXKDg7zS8OWsYVTy7LnQGzRF1RoqLiHoKk5qko5DMv1scc1oqNavUWEu+4O9dKutiaxzXx4NS1HPznH+e+oaKuxISKewiSkKfCS5D86hU1YVdcsd9hKSTecacxqNgo4OHvw+prOdhZdukqGPPe8txfqQtU3ENSyTwV+QTJq17FJOwKc++4CDKCiKtzrYiL7eH/gdXfyS279H4Yc3Rp76vUJSruVURYQYrT0i2HGAYR77g617K62B75H3jQJeqfug/GHlO6eyp1T0FxF5ExwG3ASCANzDfG3CAi+wG3A+OBLcDHjTFdIiLADcDpwB7gYmNMe2mqX1+EFaQ4Ld2moYNJiYDJv3lGsa6bUo+MnPUr1cRvlkd+AA9+O7fsU3+AsdMi1l5RglMwK6SIjAJGGWPaRWQY0AZ8FLgYeNkYc52IXAU0GWO+JiKnA58jI+7HADcYY/KaKJoVMrgoOnOMRIl3jiK+tktmb08aEZj9gQlcdfo7fI8L4rqJWo9i89/E4VoqeJ1HfwgPXJN70iX3wrhjQ9+rEiR1LYcykKKyQhpjdgI7rb9fF5FngEOAGcAJ1mG3Ag8BX7PKbzOZXqNFRIaLyCjrOooHYUTHLo8iUgvXbmPuivX0pQ1DBgU/r6VjN3t70hjAGLhlzfN8aNJITx+/fVx3T7y5W+IQZr+0AmEnkn1dVGt+DKvm5Z5cRaIOtRVuWu+E8rmLyHjgKGAtcJAt2MaYnSJyoHXYIcB2x2mdVlmOuIvIbGA2wNix9bdDjJOw/uwo/u+2rV3MXbGe3nRmpJZPfN1MmzCChpRkz00b45k6t2noYOxxYNp6HVf9850T1NJ0u7Wahg4uKGReYue+zox/3gHzrsu92SUrYdz78rYpiSR1LYcSnsDiLiJvAZYBXzDGvJZxrXsf6lE2wPdjjJkPzIeMWyZoPWqRsL70KJOBLR27STtccKmUBJ5EbB7XxDUzJjN3xXrSxtDokz+ma083KYG0gZRA157u7DWcAhyl/n7nFNq71Sn67jmIIELmPKa7J831q57lCycfwYLLprH34R/zvo4bwOlRvPgeGH9coOeaRJK6lkMJTyBxF5FBZIR9gTFmuVX8ou1usfzyL1nlnYBzB97RwI64KlyLlGMVqP2l7e5NkxLhmhmTQ1lkFxwzlokjh+XNHxNGgMPW36/NfgLtJ/ruCdtCQpZ9bj1p0sAfN+9i8tbb+FrqN7kHXvx7GP/+wM8zqSRhLYcSD0GiZQT4BfCMMeZHjrfuAi4CrrN+r3CUXyEii8lMqL6q/vbClHoVaBxf2kL5Y8IIcNi0vc77O/HrUMImPMsXerngsmlcv+pZ3v78rVzduCD3gIvuhkM/4FvnapycrORaDiU+gkTLvB94FHiajCsV4Btk/O5LgLHANuBcY8zLVmfwU+BUMqGQlxhj8obCaLRMcZRLQNwpaoPe07aibQFecNm00OfnO9brfa97Rn42j90If/hGTtHGUxcycdpHCtZbJyeVUpIvWkY3yK4QcQlyuQQkjsyTeXOX54lUiXrfop9xy8/g3qtyin777p8xpvm0QNe7cfVmfnjfRtIGGgS+dMrE8uytqtQNukF2wohTkMsV3VDsfZxD/RtXbw58rWLuG9m90HIT3Pu13LJProAJJ/DREJeZNmEEjQ3WJiYNOjmplBcV9woQRrAKWZ/ZlaPkXzlaLFGiKPzqHuZaZY3eWPtzWPnV3DJL1CNjj4w9RsjV6I9XqgcV9woQVLAKWfj2Jht9aUNDSph7xqSSiUTYCdlCSc6CXqss0Rtr58PKr+SWfeK38LbpRV22pWM3vWmDAfrSZkBsvvrjlVKi4l4i8lllQQWrkIVvv59ZOWpy4spLgZebw6+dheruvFYhCzaKeyWQVfz4zXDPf+QUfbL7Kh5vOJIFjUfSHOqOA8nXietiIaXUqLiXAD+rzGtRTT4KWfjlXnDirn8+6zOu0UnUeua9poeo3/Wun/KF1v0yk58mN14+6qghXydejs9O3T71jYp7CfDLYRJWxApZ+IXej/PL7RRMexFU157uorfnK4UF63vNdbfA77+ce/C/LYPDTuaQrV0MfqIlR2zj6Hj8OvFSu5vU7aOouJcAL6ssiIhFEWM/8Yj7y+2sf9oY5q5Yz2XvPzTvZG4co5NCeGXJdF/zjO57Yd7VuSdeuBQO/1BOXd1iGyaqJyyV3tVKqX1U3EuAn1WWT8S8xBiiZX+E+L/c0yaMICWSzU/Tlzbcsub5oidzi7Fgnc8sbTJJjexslwsum8Zra25m+qZr4THHSRfcAUec4luXcrhOkrCrlVL7qLiXCLdQFBIxP1dOVIGO+8vdPM6RPCxtSKUyQh/HZK4zrcGNqzcHFnnnM4NMdrqe3jSv/fFmpj97be7BFyyBIz4cul5+n1nb1i6Wt3digJlTRocS53JY1WWJMlISjYp7GcnnpvAT4ygCbQ/5554xKdKGHn44k4c1DR3MNXdviK3ziLLRR9PQwdlkaGkDsxpWc92gm+FZx8Hn3w4TTx1wbpiEZV7us/NvztQVYGnrdhbNPjbwWoVyWdWRF3EpNYGKe0Lws7TCWl9xpgkoFJZoC30cnUdQa9bdvrlnTGLkc0s48VnXdnYuUfc6N6o7pKVjNz296ezrnj4TuL72PdWqVkqNintESjEh5mVphbW+itnUIqz4xWkZBrVmne2bkX6QC1bOyj1g1iJ4++kDzmvb2sX1q56NxR0ybcIIBlkjBoBBDf658f0+D7WqlVKj4h6BJIaZuV0VYTa1sGnpKLxNXqmiPIJas9MmjGDWoEf4buqm3Dd8RN2us70HrCGzkUgxm3w3j2ti0eXTAvncdWJTqRQq7hFIWpiZl6vC7WsPUudC2+SVulMraM0+sZDm336W5pSjbNZCeHv+1LvOlbwp4LjD9ucLJx8RavTitQAtqM9eXTBKJVBxj0DSrDG3cHft6R6QWjZInfNtk+d1nzAun6J4YhH89jO5ZectgHecEeh0d9v9hB3iWYAWtSNQlDhRcY9A0qyxIMJt13lZe6fnJrdBruP3fsks+icXw52fzi077zfwjjNDXSbM5xV1AZqN81k0poRzp47h7JChkooSB7pZRwmoRE6PIPcMIsJhdj2CjKXr3FM1lk0pnrwd7pydW/bxX8M7z4p+zRD45dAJsquTc4MOyF1YpQKvxI1u1lFGKjXZ6h76e4l0EAs0XzoD+3pzph82wEJtbEjR11ekm+qpJbD88tyyc2+FSWG2yCiesAvQnNiWvz15ay+sqvS8jFJ/qLjnIYoFHiTipNT4dTBR5wq8rufsKPrShvOOHsMhw/eJNlp56g5Yfllu2bm/gkkfC3edEhJ2AnVZeydL2zqL7/AUJSIq7j5EtcALRZyUg3yx1U4LFAi03N/reu6OIuwSfACeXgrLLs0tS5ioR8F+1jOnjE7MvIxSf6i4+xA13LFQxEk5yG69ZwZma3TmcQnaeXlZ/HZHYcd6h8JL1M/5P5g8M+yVSk6x+dxV1JVKoeLuQ77IkHxf9kqHSdpb76VNJrmXX7bGMJ1XPp/zsvZOunvTLG/vLDy6Wb8cll6SWzbzF/CucyK1tdQkcbGaogSloLiLyP8BZwAvGWMmW2XzgMuBv1uHfcMYc4/13teBS4E+4EpjzB9KUO+S4yVoQb7spQiTDGM9OkVb6M/WGDZ5VZBY7cAdRAhRT9LuQeVarJakNiu1QxDL/VfAT4HbXOU/Nsb8wFkgIu8EZgGTgIOBVSJyhDGmL4a6lh23oAX9ssc5HA9rPXqJtt8KVq+VrG1bu7KTgb19+e9ZcJSy4U644+LcsrNvgXef69vW82/uDzlcdHnpLeV8wlqurfB0dKCUgoLibox5RETGB7zeDGCxMWYv8LyIbAaOJne7hKqlEi6XsNaj18jBuaNQd086k5PdmJxNQW5cvTmbxteO9oHCnZjnKOUvK2DJJ3MPPvtmePfH87Z1ueXiAbKunlIKXSFhLcditaSlslBqh2J87leIyCeBVuDLxpgu4BCgxXFMp1U2ABGZDcwGGDt2bBHVKB+VWJkaxffvHjk4ryHWbkq2mCxr78yKakqEvrTJCruQP8HWgHv95S5Y8oncAz42H95zXqC2uidmS728LgnCWuk5GqV2iSruPwO+Teb7923gh8CnwHNlu+d31BgzH5gPmRWqEetRdsodARHV9+93DfcmG0L/bk+Q2TLPmMzvwEvnn/kd3P5vuWUf+zm8Z5b38T7MnDKapa3b6cu/dPsAAB7cSURBVOkzDGoQZk4ZHer8fHh1hkHmHUrtMklaKguldogk7saYF+2/ReRm4G7rZScwxnHoaGBH5NrVCMVOmEX1/ee7xsr1Ozlt8igmjhzGsvbOrMCF2r3pmbvh9gtzyz56Exx5fsE2eT2T5nFNLJp9bLZ84wuvc/2qZzlt8iguOCb66M5PpAsJa9jnHPVz1pBJpRREEncRGWWM2Wm9/Biw3vr7LmChiPyIzITq4cDjRdeyjMQduVAK66+YobwdKtndm2bdlpezm0mHavNffw+LL8gtm/H/4KgLs/dwX8+dk8bvmdhCt3DtNr5x59MAPLppFw9tfIlPf/BtkZ5dPpHOJ6xhXGJBUwUXi0bWKEEJEgq5CDgB2F9EOoFvASeIyJFkXC5bgE8DGGM2iMgS4C9ALzCnmiJlSiHEpfDrRl1p6lefOdMPCyjq98Bil1XuEHXwfoaQK+ZnTxld8JmsXL8z5/V9f3mRRzb9PdJnErUzDOMSiyNVcCHKFVmjHUhtECRaxmuM/Ys8x18LXOv3fpIphRAHFZaoGzfHESpZkI0rYZHLf37WT2HKJwYc6pVbB8h5rkJm4+/unswEr1eKhtMmj+LRTbtyypyiGfZZRfVrB3WJFZsqOAjlmADW0Mzaoa5XqJZjV/ogwlLMFyqOUElfNt4Li1yRLmf9L0z5pPfxeOfWmThyWM5zPXvKaCYdvG82JPOauzcwceSwnLrYPvbb121jw87XMOlMKoWmoYMjPati/dqFtjH0e65x/j+VI7ImCRFESjzUrbiXa1f6IBZ5lC9UIbHJR0Ghe/YPsNAVk37mT6D5ooLX9sqt4/VcWzp254RkerX5gmPGcsExY3OeYSXEJ8g2hhA8VXAxE6+ljqzR0MzaoW7F3SkSe3sy8d72lzOuL01QizzsFyqo2ITm2ftgoWv16Jk3QPPFBU8NYtn6xd6HiqUnXms4CO4OxWsbQz/cdS/W7VHqyBoNzawd6lbcp00YQWNK6O7LLNpZ2tYZLW1tHsKkKwjzhSpGbDzZdD8syM3zsvV93+XuQR9m2v4jaC5wepTOJqqIVEJ84rRmnZ9dd2+a61c9m3dP10qgoZm1Qd2Ke/O4Js6dOoaFa7dhgL6++If4xVincV03L5tWwQJXmt2P/Ii2A8+2xHpjXuvSttb/9sobkTob56Rw0Ggf53nlIs4Oxf7s7Oe1ZtOubEhq0OtqNIsShLoVd4Czp4zOWcAT9xC/kChE/ZJufOF1Jh40jAPf+iY+EyX2e/Mq+E2uqM9Lf4ozL52b8Yc7ctH4jThyttlrSNGYyqQuCOpWChLzHuT8combs0MpNsf7gsumcf2qZ1mzaVfobfjKEc2inUdtUNfiXo4hvp+VGfVLet09z3DTIx3Wq1eZPvHA4PXe/AD85uycork9l3Bb34doEDggT1ifG6d7oa8vzayjx3JwgG323O2e6Yh5D+KmqHSoXhz3bx7XxBdOPoJ1W14ObViUekK50s9XiY+6FneonH8xaoTM/Ec7cspuX7et8GTqcw/Crz+WW3b6D2g76ByW3NJCQzpYWJ8TdwdwtpUHxo5DDxoZZCCUm6LSoXpx3T+qYVHqaJZKP18lPupe3CtFlC/psvZOK8FXPxt2vsbTf3vV28p6bjX8+qO5J5z2P3DMbACawVdg7L/9xNotThDMveJu98wpo5k5ZXRgN0WlQ/XivH8Uw6LUo81KP18lPsSYyidknDp1qmltba10NcpOGN+mvZGFne9cgPeOb6J1axdpAw0CXzplYmYis+MhuG1G7gVO+z4c8+lQdQszPL9x9WZ+eN/GgXXxuK6976ozOsm+ny0q+e4X5Ln5HROHP7nWfdK13r5aQkTajDFTvd5Ty72ChLHcWjp209vXL+wXHDOWs6eMzgiwtYz/7W/8Gea5AhdPvQ6mfTZ03cIOz4NYfF7+dpswFmmh57Zw7bYBG5LYUTlx+JPL6cqr9OSxUr2ouFcJXj7u5nFNzD1jEvfctZjfDLo2N//mh78Hx/57bPcrNDwPIs6FOow4RKVtaxdzV6yn1/JfdTvuU23+ZJ3cVIpBxb1K8BTP5x/lgpVncMGg/uPWvO1LvP8T38pYfK7Y8TBWYBTfbiFxjurPDbtBeJ9jYiIlkr1PtfmTq60zUpJFXYt7tflfs+L5/KMw74yc967tvZBfy5ksOH5aoLS7QazAsJZ0oTzuUTqMKFkvhwzKZJxMpYRrZkzOHl+J1a3FUG2dkZIs6lbc4xjyxj1sLthRbFkDv/pIbtmHvk3b6E8wvGM3CyYM3BDbmSa33PHR4N2hhLlv3Fkvq8mfXG2dkZIs6lbc4xjyxjlszttRbPkj/Or0nOP/NOHzDPngFzNiRW6oop/FV+74aGBAbvewz8evLWE2CK9maqktSnmpW3GPY8gbxzVskdrhys/S0rGbZp6BX56Wc3zn1Ks4ee2RdD+TZvCmFs/Rgp/F52cFxuFa8noWG194fUBu97DPZdqEEUVvEK4o9UjdinscQ94g18gnnDn5WVJCY0OKvr40xzQ+y5yHL4CHHQefPA/e/0VWrN5Md+/GQJkmvUQfchcmxRke6H4Wy9s7s+/bud29cD8jrzo5Y+ZrbaLRq/3qilGKpW7FHeIZ8ua7RiHhzMnPkjZ8ZVIXn9nsCl886VvwgS9lXwYdLQTdxHlZe2fWdVKsUDqfRdvWLu5o3Z59r7Eht67O/O/2ht12nQqJdy1NNHqlS3Y/DxV4JQp1Le6lJqhIvbvvGZYM/i/Y7Dj5xG/C8f8x4JpBRwtBNnFe3t7J0rbOrOukISWxCWVLx+5srLkA5zQPXI3a3ZsmJTJgR6ZC4l1LE43uz2Tl+p01NSpRKkdNiHtSh7EFRSq1ib82zIIGR+GJ/wnHfyXvdf1GC3n99+MGZns0kLPq9dypY7LXXbh2GyvX7+S0yaOy+5kW03bnalSnoGEMqZQg9KcLDiLetTLR6H5Op00eFSlbpKK4qXpxT/Lkmq9IbV8Hvzg59+DpV8MHvzpg8VHQHCk51nBKEBFSmLzZHgGWO/LZ25kdF67dxjfufBqARzftAggt8PkE2i1oXjs3JVG8S2FEeD2niSOHJdJYUaqLguIuIv8HnAG8ZIyZbJXtB9wOjAe2AB83xnSJiAA3AKcDe4CLjTHtpal6hnyujyCLakpNjkjlEXW7bkH8r14dmvM5pPsy7pDGlDD3jEk57XSLplckyvxHnsup4sr1OyNZ734CXY1ulVIaEe7nlMSOTak+gljuvwJ+CtzmKLsKeMAYc52IXGW9/hpwGnC49XMM8DPrd8nIFwcdxyrNIBTsMDpb4ZaTcstO+DqccFVOUVD/q1eHZj8He3IUwBjjG6Fi454EvfCWFvb2pHOOOW3yqGjtDnjfasAvjr+aOiilvigo7saYR0RkvKt4BnCC9fetwENkxH0GcJvJ5BFuEZHhIjLKGLMzrgq78bMC/b6McU9W5bXoOtvglhNzT/jgVTD9657XCup/9erQ7OewvL2TO1q3e255V0iM7WdmyPjgx40Yyuzj3+ZptSfZHVYK3M+8aejgumq/Un1E9bkfZAu2MWaniBxolR8CbHcc12mVDRB3EZkNzAYYOzb8kN+JlxVYqlWazhC+rj3d3pOXjR1ws0vUj/8qnHi17/X8JhInjhyWzX/ubK9Xh2Y/h7OnjA4UBul2VTUNHZzzfGYf/za69nTTtrVrwLF+k7alpJIT5+5nXmux9krtEfeEqniUee4GYoyZD8yHzGYdUW5WaAl6mFWaQe9nC2TaZBo7qKF/8dFRjc8PXHzkI+ru6+XLvbKsvZNuK3TReUy+CVb3NfzEyMvP37Wn2zP+fOMLrzN3xfrMqMBqd29vJpd8mNWnUUjCSMH9XEsVa5/U6C+luogq7i/a7hYRGQW8ZJV3AmMcx40GdhRTQT+CfNn9VmlG/cLkhPCR6bX60oYvTv4nV2y6LPfgD/wHnPTNwNfz8+O6j1nW3hnKKrfxG8m4r9+1p5s50w8bkHxsWXsnS9Ztz8au9/YZTnrngaz+60ukjeGauzcwceSwkolR0izlUk0KJ6ETU2qDqOJ+F3ARcJ31e4Wj/AoRWUxmIvXVUvnbK/FltwXSvu+7pYO7hvwnbHIc9IEvw0lzQ10vnx/XeYwI3L5uO+m0Ycig/IuTvFw2thg1DR2c7Uj8RN9dvuv1vbl50lPCgcOG5CxA8rpvXCRxVWoxhoKfdZ60TkypXoKEQi4iM3m6v4h0At8iI+pLRORSYBtwrnX4PWTCIDeTCYW8pAR1Bgp/2UsZk7z5yTWc1/5vuW++/4uZ/C8Rruflx7V3EJoz/bBsmoDb123PCqwzy6LzWTQ0pLijNWNhuy0/+7e7A/EKh2zp2J3jopn3uw39K1kFrpkxmYkjh7HMipPPd99icdenlO6KcrhE8lnnSezElOokSLTM+T5vneQusKJk5hRbqSDkGxaXbGi780maf3k8ObuUHvd52o74YqYe1sRj2B2P7GM2vvB61uWTNv1ZFG3r3LmZecqRKsD5LP72yhssfnwbaQP/6klzze82MPfM/lh3r1wyc6YfltfF09KRu3/rrKPHZiNovO67tyfjxokrzLRcbopy3SufdV6NawCUZFLVK1T9hsWxD213PgU//0Bu2fuuhFO+PUAQLj52PLeseX7A5sxuvDqArj3dCBlfforcLIpOl1BKcncYsp8FZFacpoRsJ/Fk56ucf3MLiy7PxPkXyiWTL4bevZLVvq/doS1t3U53n8FY95k5ZXTR4lRON0W57hUkd46KulIsVS3ufnj5sm907ScaCE9R/xyc8p3sS7crZf6jHVlh7fYRCD8LcdqEzBZxXl/6Qhad85qZhcL9Vr5zstYvl4zfswuT6+XcqWNYuHZbZqK5z7/tYazScropctxbKWHHK2/khIHGRfO4zMbmdu4eFXKlFNSkuLsnD0OnUH3habjp/bllx14BH742+9IrNlxEstEkkLs5s1PU/CzEQiKaz6Jb7nC3pIyhQcDKQpAjio0poacvE8o46eB9B3R6XnUIKshnTxmd9cH7zYNE2ce11G4K98Ygy6xsmYse38YyR/hpnPez/yfXbXm5pFFGSv1Sk+IO/ULotZ+o7xfphfVw03G5ZdPmwKnfzSkqGBvu2pzZ63g/azTKkNzOnW53K42NKeadOYn1O15FyIiuXQ8sq94A8+5a7zvxWijMsm1rF8vaO3OuX0iIo7o9Summ8GrfIcP3obevdO4ZjYhRykHNirtNoGH9K9vhhveA6XOc+O9w6vc8r+kXGw54ZvTzOj5Oa7SlY2DudK+UAfbEaCbVb+Z4r006Co0yAM6f/xjd1jXuaOtk0eXei6ucJDESJMgcQ9z1TOJzUGqPmhf3vNakl6jnWXzkt0y/kOXt58eOYqF7tSM72WqNGCYfvK/n+e6QSYwZkIMmyCijpWM3PX0DffpJcLGEJeocQzEEvb6uVFWKQZzhdZVi6tSpprW1tXw3fLUTbjgS0j39ZTNuhKMyset+qYLPn/9Y1l8976zJoWKug3xRg+636uWvXrh2G3NXrA8VpQMDsxpefefT2UnRBoEvnTIxK+hOH7zTch/cmMpa7tVIEkVUV6oqQRCRNmPMVK/3at5yz8FL1M/6KUz5RPal35dqWXtnVsy6+wzrd7zKdz/2rsC3dvuxg6YQCJqoq2tP94Dt6vyiWrxCKO06OH33DQ3eo4zmcU0smn3sAJ97tZLE0EP1yyvFUh/i/urf4CdHQd/e/rKz/hemfHLAoX5fKndGNK8MaUEIsr9pt8O3bR/bmOpPUOblpw3ixw2S8tdv31M3xQhiEi3lpKF+eaVYalvcX9uREfXef2WLHjziP9n3uMtCTfq1be0CoLFB6OszAxby2AQRLb/O4/U3egasTs05ts9w8jsP5Mgxw0NlwXTWLWxysZkebSwWdTcEI4nzE0p1UZvi/toO+MkU6H0jW7T1fd/jw48eSvfTaQY/0+IrKu4vFTis54YUHz9mjOfKy7atXZx/c0tWGP180H6dx81rns857vZ12zjvvWNpTEl21edDG1/iMx98WyRr2tlR/KsnzZeXPDFgI45yCErS3Q1JGlUk0V2kVA+1Je6v7YD/nQo9/+wvO+N6mHoJd6/eTHfvxkCi4vxSOePk+/rSHDJ8H8/zlls51yHjVvn5w8/xHg8r20tAb1y9OSfjImTSBmx8cQNHjhnO41syI4eePsPygDlb3CLVNHQwzlts2b0nuwm2W+CLEZRC4hiHu6FUAlyqUUWSOgylfqgNcX9tJ/xvs6eo20QVlaDnuWOOHnjmRVY986KnSLgFdNqEETQ2SDb23KanN83e3tz9TIPENnmJlDNvjZOom18HvW8+95Htetr4wuuBI49K6dYpxahC3VBKpahuce/rhe9PgL2v9pd95Efw3ksHHBrV5ZDvPKdFNnPKaJa2bqenz2QTd3ktEPK7x3lTx7Bg7bZsmZBJG3Dee8fyzM719PQZGhoke18vt5BdF6/Mj3bemn8F3Pw6CkHF0S5z72rlzFFf7D2iUIpJzKS7oZTapbrF/anF/cLuI+pOorocvM7zssjs8MBdr+/loY0veW5S7YczL0tDQ4pzmkcz+eB96drTzbyzJrNhx6vc0bqdxY9vy9luz12XxpRgYEDmx+ZxTVx87HhueqQje8/jD98/NqsdwomjU/QgeEdYyiiSUsw5aNSLUimqW9yPvBAOOxmGjSzJ5fP5Sv2WrdsJvFIp4cR3HMT0iQdmwxoLWe9+E7mDreic3rR3HLs7qsbGnflxw87Xcu65ZvOuWLMeerXBLxunM4Vx2mRSHAcRv3KsHo3zmhr1olSK6hZ3kZIKez5fqZdF1tKxO+sO6UsbHvzrSzy88aWMS8VKJJbPUvabyO3pTSP4b8jsTlWLSDYe3hmyedrkUTy6aVf2tTGEdhM4UzDk85NvfOH1vNk4m8f1p72dNOqtDNtnUGDxq7Yokmqrr1IbVLe4lxC/hFnL2zObXcycMtrTImtI9af9TacNdtaa3rRh7or1gdO7ujuPs6eM5uwpoz0tQC+L2eu4C44Zy7bd/2T+ox0Yk/Fxh3ET2B2e3YFBbuoBZ4eYEqEvbXzdLc50Ceu2vKwTjYoSMyruLvySgzUNHcz5N7dkwx2Xtm5n0exjs9kgISOy18yYnBUte0Wp7SlJGxMqza1X5xE0xt3vuA9NGslre3sjpQ2wOzxnxE13bzobnpnrR8+MVowZOO/QtrWLuSvWZztBv01NFEWJjoo7uYLudCU4N2R2xrFDxrftJUgXHDM2J+3vxhdez0noFcZSjjqc95srcLuavFbZ5sMeTbgjbozrfbtD9NvQuqVjd05cv3NTEyU/GjOvBKXuxd3tSnAm37LztNsJtZwMavAXJKcoN49r8szxXop2FNp5qtiwPHs0say9kyWt2zOpGBokm6Yg6OShHZbp3tREyY/GzCthKErcRWQL8DrQB/QaY6aKyH7A7cB4YAvwcWNMV3HVLB05rgRjSKUEIdeV4E6o9e7R+zL3zElZP3MhMSvlhNrCtdu4fd02/rLztaw1bHxi7MOE5fm1y27LTMv/by9Ecr5XqK3liiCJy8pNirWsMfNKGOKw3KcbY3Y5Xl8FPGCMuU5ErrJefy2G+0Qm35cziCthwDEOYa+kJbVw7bZsCgE3KRkYWhg0VDHoSlMgcPvdn0GpI0ji+mwq/Rk70Zh5JQylcMvMAE6w/r4VeIgKinuhL6efFdm2tStH+LyOqaQl1ba1i/mPPOf5ngDHHbY/Xzj5CE9Rtjsmv0RnQdsV9Dj3RieLZh9b8ucU12eTJGtZY+aVMBQr7ga4T0QM8HNjzHzgIGPMTgBjzE4RObDYShZDkC+nU9RsnH54Oz69kNVfrCUVdPjvDEl0krKSxwwelPIUdifuRGfX/G5DdkQStF1Bj3NvdLKsvRPwDteMi7g+m6RZyxozrwSlWHE/zhizwxLw+0Xkr0FPFJHZwGyAsWPjWwLvJugmFu4oErtDSBv/+PQ4Lakww39nSKIA40YMZfbxbws1cetOIPZk56tceEt/KuQg7Qp6nHtjk12v7y25qyOuz0atZaVaKUrcjTE7rN8vicidwNHAiyIyyrLaRwEv+Zw7H5gPmT1Ui6lHPoJ8Od3WvUA2cgYyi5FKPRwPM/x3d1g//PiRBePg3diJzrp9NroOaiHmO84eiUw6eN+c+u4/bEhZXB1xWblqLSvVSGRxF5E3AyljzOvW36cA1wB3ARcB11m/V8RR0WIo9OX0Wg066eB9M/HpacNgn5WcQa3tIO6WfCMMr8nIfB3WwrXbWLl+J6dNHuWb7qB5XP8+qEvbOn2374uK+9nMO7N/ohoybqGkuDoUpRYpxnI/CLhTROzrLDTG3Csi64AlInIpsA04t/hqlhYvsQwSnx7E2g7aAeSb2PU636/DckbQ2Hlk8gm8M6wxTreD+9nYawZs1NWhKKUlsrgbYzqA93iU7wZOKqZSlcBLLMNa/F4W6HKP3Oph4uHdIrmsvTOvKK5cv3PA60JpfaO6HcKEmLqfjbo6FKW01P0K1WIo5B6xV7Zmc6s3hHdBuDM+Lm3rpLfPfxTgzvwY52YcTqKGmCqKUh5U3IugkC/dvbL1nOZwibogVyR3vPIGix7fltcNZFvphXzuxRI0xFRFXVEqg4p7RIL40t2uiZkhE3XZOBceLQswEXnBMWNLJuo2SYv/VhQlFxX3iAS1XON0TSTJ1ZGkuiiKMhAV94gEtVzjdk2oq0NRlCCouEek3i3XJCXUUhRlICruRVDPVnSSEmopijKQVKUroFQntluqwSO1sKIolUctdyUUzvDPenZLKUrSUXFXAuPlZ3emFFAUJTmoW0YJjJefXVGUZKLirgRG/eyKUj2oW0YJTL2HfypKNaHiroSinsM/FaWaULeMoihKDaLiriiKUoOouCuKotQgKu6Koig1iIq7oihKDaLiriiKUoOIMabwUaWuhMjfga2Oov2BXT6H1xL10k6on7ZqO2uPJLd1nDHmAK83EiHubkSk1RgztdL1KDX10k6on7ZqO2uPam2rumUURVFqEBV3RVGUGiSp4j6/0hUoE/XSTqiftmo7a4+qbGsife6KoihKcSTVclcURVGKQMVdURSlBqmYuIvIfiJyv4hssn575pEVkXtF5BURudtVfqiIrLXOv11EBpen5uEI0c6LrGM2ichFjvKHRGSjiDxh/RxYvtoXRkROteq3WUSu8nh/iPX5bLY+r/GO975ulW8UkQ+Xs95RiNpWERkvIm84PsObyl33MARo5/Ei0i4ivSJyjus9z//jJFJkO/scn+dd5at1CIwxFfkBvg9cZf19FfDfPsedBJwJ3O0qXwLMsv6+CfhspdpSbDuB/YAO63eT9XeT9d5DwNRKt8OnbQ3Ac8AEYDDwJPBO1zH/Dtxk/T0LuN36+53W8UOAQ63rNFS6TSVq63hgfaXbEGM7xwPvBm4DznGU+/4fJ+2nmHZa7/2j0m0o9FNJt8wM4Fbr71uBj3odZIx5AHjdWSYiApwILC10fgII0s4PA/cbY142xnQB9wOnlql+xXA0sNkY02GM6QYWk2mvE2f7lwInWZ/fDGCxMWavMeZ5YLN1vaRSTFuriYLtNMZsMcY8BaRd51bT/3Ex7awKKinuBxljdgJYv8O4G0YArxhjeq3XncAhMdcvLoK08xBgu+O1uz2/tIZ/30yYWBSqd84x1uf1KpnPL8i5SaKYtgIcKiJ/FpGHReQDpa5sERTzuVTTZ1psXd8kIq0i0iIiiTQsS7rNnoisAkZ6vHV1sZf2KKtYTGcM7czXnguNMX8TkWHAMuATZIaJSSDI5+B3TKI+wwAU09adwFhjzG4RaQZ+KyKTjDGvxV3JGCjmc6mmz7TYuo41xuwQkQnAgyLytDHmuZjqFgslFXdjzMl+74nIiyIyyhizU0RGAS+FuPQuYLiINFoW0mhgR5HVjUwM7ewETnC8Hk3G144x5m/W79dFZCGZ4WRSxL0TGON47fU52Md0ikgjsC/wcsBzk0TktpqMk3YvgDGmTUSeA44AWkte6/AU87n4/h8nkKL+/4wxO6zfHSLyEHAUGR9+YqikW+YuwJ5NvwhYEfRE68uyGrBnsEOdX2aCtPMPwCki0mRF05wC/EFEGkVkfwARGQScAawvQ52Dsg443IpcGkxmEtEdOeBs/znAg9bndxcwy4owORQ4HHi8TPWOQuS2isgBItIAYFl6h5OZbEwiQdrph+f/cYnqWSyR22m1b4j19/7AccBfSlbTqFRwtnoE8ACwyfq9n1U+FbjFcdyjwN+BN8j0th+2yieQEYPNwB3AkErPThfZzk9ZbdkMXGKVvRloA54CNgA3kLCIEuB04FkyVsvVVtk1wFnW32+yPp/N1uc1wXHu1dZ5G4HTKt2WUrUVmGl9fk8C7cCZlW5Lke18r/Vd/CewG9iQ7/84qT9R2wm8D3ja+jyfBi6tdFu8fjT9gKIoSg2iK1QVRVFqEBV3RVGUGkTFXVEUpQZRcVcURalBVNwVRVFqEBV3RVGUGkTFXVEUpQb5/4fFXvZI6uqlAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(diabetes_X, diabetes_Y, '.')\n",
    "plt.plot(diabetes_X, sr.intercept_ + sr.coef_ * diabetes_X, '-')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from sklearn import linear_model\n",
    "reg = linear_model.LinearRegression()\n",
    "reg.fit(diabetes_X, diabetes_Y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[949.43526038]\n",
      "152.1334841628967\n"
     ]
    }
   ],
   "source": [
    "print(reg.coef_)\n",
    "print(reg.intercept_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
